<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>NLP —Å –≤–µ–∫—Ç–æ—Ä–Ω—ã–º–∏ –ø—Ä–µ–¥—Å—Ç–∞–≤–ª–µ–Ω–∏—è–º–∏ –∏ –Ω–µ—á–µ—Ç–∫–æ–π –ª–æ–≥–∏–∫–æ–π</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            max-width: 800px;
            margin: 0 auto;
            padding: 20px;
            background-color: #f5f5f5;
        }

        .container {
            background: white;
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }

        textarea {
            width: 100%;
            height: 100px;
            margin: 10px 0;
            padding: 10px;
            border: 1px solid #ddd;
            border-radius: 5px;
        }

        button {
            background: #007bff;
            color: white;
            padding: 10px 20px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            margin: 5px;
        }

            button:hover {
                background: #0056b3;
            }

        .result {
            margin-top: 20px;
            padding: 15px;
            background: #f8f9fa;
            border-radius: 5px;
            border-left: 4px solid #007bff;
        }

        .vector-visual {
            display: flex;
            flex-wrap: wrap;
            gap: 2px;
            margin: 10px 0;
        }

        .vector-cell {
            width: 20px;
            height: 20px;
            background: #e9ecef;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 10px;
            border-radius: 2px;
        }

            .vector-cell.active {
                background: #007bff;
                color: white;
            }

        .similarity-bar {
            height: 20px;
            background: #e9ecef;
            border-radius: 10px;
            margin: 5px 0;
            overflow: hidden;
        }

        .similarity-fill {
            height: 100%;
            background: #28a745;
            transition: width 0.3s ease;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>NML —Å–∏—Å—Ç–µ–º–∞ —Å –≤–µ–∫—Ç–æ—Ä–Ω—ã–º–∏ –ø—Ä–µ–¥—Å—Ç–∞–≤–ª–µ–Ω–∏—è–º–∏</h1>

        <div>
            <h3>–í–≤–µ–¥–∏—Ç–µ —Ç–µ–∫—Å—Ç –¥–ª—è –∞–Ω–∞–ª–∏–∑–∞:</h3>
            <textarea id="inputText" placeholder="–í–≤–µ–¥–∏—Ç–µ –≤–∞—à —Ç–µ–∫—Å—Ç –∑–¥–µ—Å—å...">–ü—Ä–∏–≤–µ—Ç —è —Ö–æ—á—É –Ω–∞–π—Ç–∏ —Ä–∞–±–æ—Ç—É –≤ –≥–æ—Ä–æ–¥–µ –º–æ—Å–∫–≤–∞ –≤–æ–∑—Ä–∞—Å—Ç 39 –ª–µ—Ç –≤–µ—Å 68 –∫–≥ —Ñ–æ–±–∏–π –Ω–µ—Ç –∞–ª–ª–µ—Ä–≥–∏–π –Ω–µ—Ç</textarea>
            <button onclick="analyzeText()">–ê–Ω–∞–ª–∏–∑–∏—Ä–æ–≤–∞—Ç—å —Ç–µ–∫—Å—Ç</button>
        </div>

        <div>
            <h3>–¢–µ—Å—Ç–æ–≤—ã–µ –∑–∞–ø—Ä–æ—Å—ã –¥–ª—è —Å—Ä–∞–≤–Ω–µ–Ω–∏—è:</h3>
            <button onclick="testQuery('—Ä–∞–±–æ—Ç–∞ –ø—Ä–æ–≥—Ä–∞–º–º–∏—Å—Ç')">üíª –†–∞–±–æ—Ç–∞ –ø—Ä–æ–≥—Ä–∞–º–º–∏—Å—Ç–æ–º</button>
            <button onclick="testQuery('–º–æ—Å–∫–≤–∞ –≤–æ–∑—Ä–∞—Å—Ç 30')">üè¢ –ú–æ—Å–∫–≤–∞, –≤–æ–∑—Ä–∞—Å—Ç 30</button>
            <button onclick="testQuery('–∑–¥–æ—Ä–æ–≤—å–µ –∞–ª–ª–µ—Ä–≥–∏—è')">üè• –ó–¥–æ—Ä–æ–≤—å–µ, –∞–ª–ª–µ—Ä–≥–∏–∏</button>
        </div>

        <div id="results"></div>
    </div>

    <script>
        // –ê–ª—Ñ–∞–≤–∏—Ç –∏ –∫–æ–Ω—Å—Ç–∞–Ω—Ç—ã
        const RU_ALPHABET = '–∞–±–≤–≥–¥–µ—ë–∂–∑–∏–π–∫–ª–º–Ω–æ–ø—Ä—Å—Ç—É—Ñ—Ö—Ü—á—à—â—ä—ã—å—ç—é—è';
        const EN_ALPHABET = 'abcdefghijklmnopqrstuvwxyz';
        const COMBINED_ALPHABET = RU_ALPHABET + EN_ALPHABET + '0123456789 ';

        // –°–æ–∑–¥–∞–Ω–∏–µ –Ω–æ—Ä–º–∞–ª–∏–∑–æ–≤–∞–Ω–Ω–æ–≥–æ –º–∞—Å—Å–∏–≤–∞ –¥–ª—è –∫–æ–¥–∏—Ä–æ–≤–∞–Ω–∏—è —Å–∏–º–≤–æ–ª–æ–≤
        function createNormalizedArray(min, max, count) {
            const result = [];
            const step = (max - min) / (count - 1);

            for (let i = 0; i < count; i++) {
                const value = min + i * step;
                const normalizedValue = (value - min) / (max - min);
                result.push(normalizedValue);
            }

            return result;
        }

        const normalizedArray = createNormalizedArray(0, COMBINED_ALPHABET.length, COMBINED_ALPHABET.length);

        // –ù–æ—Ä–º–∞–ª–∏–∑–∞—Ü–∏—è —Ç–µ–∫—Å—Ç–∞
        function normalizeText(text) {
            return text
                .toLowerCase()
                .replace(/[^a-z–∞-—è—ë0-9\s]/g, '')
                .replace(/\s+/g, ' ')
                .trim();
        }

        // –°–æ–∑–¥–∞–Ω–∏–µ –≤–µ–∫—Ç–æ—Ä–Ω–æ–≥–æ –ø—Ä–µ–¥—Å—Ç–∞–≤–ª–µ–Ω–∏—è —Ç–µ–∫—Å—Ç–∞
        function textToVector(text) {
            const normalizedText = normalizeText(text);
            const vector = new Array(COMBINED_ALPHABET.length).fill(0);

            for (let char of normalizedText) {
                const index = COMBINED_ALPHABET.indexOf(char);
                if (index !== -1) {
                    vector[index] += normalizedArray[index];
                }
            }

            // –ù–æ—Ä–º–∞–ª–∏–∑–∞—Ü–∏—è –≤–µ–∫—Ç–æ—Ä–∞
            const magnitude = Math.sqrt(vector.reduce((sum, val) => sum + val * val, 0));
            return magnitude > 0 ? vector.map(val => val / magnitude) : vector;
        }

        // –§—É–Ω–∫—Ü–∏—è –Ω–µ—á–µ—Ç–∫–æ–≥–æ —Å—Ä–∞–≤–Ω–µ–Ω–∏—è (–∫–æ—Å–∏–Ω—É—Å–Ω–æ–µ —Å—Ö–æ–¥—Å—Ç–≤–æ)
        function fuzzySimilarity(vec1, vec2) {
            if (vec1.length !== vec2.length) return 0;

            let dotProduct = 0;
            let mag1 = 0;
            let mag2 = 0;

            for (let i = 0; i < vec1.length; i++) {
                dotProduct += vec1[i] * vec2[i];
                mag1 += vec1[i] * vec1[i];
                mag2 += vec2[i] * vec2[i];
            }

            mag1 = Math.sqrt(mag1);
            mag2 = Math.sqrt(mag2);

            return mag1 > 0 && mag2 > 0 ? dotProduct / (mag1 * mag2) : 0;
        }

        // –ü—Ä–æ—Å—Ç–∞—è ML-–º–æ–¥–µ–ª—å –¥–ª—è –∫–ª–∞—Å—Å–∏—Ñ–∏–∫–∞—Ü–∏–∏
        class SimpleMLModel {
            constructor() {
                this.patterns = {
                    '—Ä–∞–±–æ—Ç–∞': textToVector('—Ä–∞–±–æ—Ç–∞ —Ç—Ä—É–¥–æ—É—Å—Ç—Ä–æ–π—Å—Ç–≤–æ –≤–∞–∫–∞–Ω—Å–∏—è –∫–∞—Ä—å–µ—Ä–∞'),
                    '–ø—Ä–æ–≥—Ä–∞–º–º–∏—Å—Ç': textToVector('–ø—Ä–æ–≥—Ä–∞–º–º–∏—Å—Ç —Ä–∞–∑—Ä–∞–±–æ—Ç—á–∏–∫ it –∫–æ–¥ python java javasctipt'),
                    '–≥–æ—Ä–æ–¥': textToVector('–±–∞—Ä–Ω–∞—É–ª —Å—Ç–æ–ª–∏—Ü–∞ –≥–æ—Ä–æ–¥'),
                    '–≤–æ–∑—Ä–∞—Å—Ç': textToVector('–≤–æ–∑—Ä–∞—Å—Ç –ª–µ—Ç –≥–æ–¥ —Ä–æ–∂–¥–µ–Ω–∏—è'),
                    '–∑–¥–æ—Ä–æ–≤—å–µ': textToVector('–∑–¥–æ—Ä–æ–≤—å–µ –∞–ª–ª–µ—Ä–≥–∏—è –±–æ–ª–µ–∑–Ω—å —Ñ–æ–±–∏—è –≤–µ—Å –∫–≥ —Ä–æ—Å—Ç —Å–º 0123456789'),
                };
            }

            predict(text) {
                const vector = textToVector(text);
                const results = [];

                for (const [category, patternVector] of Object.entries(this.patterns)) {
                    const similarity = fuzzySimilarity(vector, patternVector);
                    results.push({ 
                        category,
                        similarity: similarity,
                        confidence: this.fuzzyConfidence(similarity)
                    });
                }
                return results.sort((a, b) => b.similarity - a.similarity);
            }

            fuzzyConfidence(similarity) {
                // –ù–µ—á–µ—Ç–∫–∞—è –ª–æ–≥–∏–∫–∞ –¥–ª—è –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–∏—è —É–≤–µ—Ä–µ–Ω–Ω–æ—Å—Ç–∏
                if (similarity > 0.8) return '–æ—á–µ–Ω—å –≤—ã—Å–æ–∫–∞—è';
                if (similarity > 0.6) return '–≤—ã—Å–æ–∫–∞—è';
                if (similarity > 0.4) return '—Å—Ä–µ–¥–Ω—è—è';
                if (similarity > 0.2) return '–Ω–∏–∑–∫–∞—è';
                return '–æ—á–µ–Ω—å –Ω–∏–∑–∫–∞—è';
            }
        }

        // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –º–æ–¥–µ–ª–∏
        const mlModel = new SimpleMLModel();

        // –§—É–Ω–∫—Ü–∏—è –∞–Ω–∞–ª–∏–∑–∞ —Ç–µ–∫—Å—Ç–∞
        function analyzeText() {
            const inputText = document.getElementById('inputText').value;
            const resultsDiv = document.getElementById('results');

            if (!inputText.trim()) {
                resultsDiv.innerHTML = '<div class="result">–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –≤–≤–µ–¥–∏—Ç–µ —Ç–µ–∫—Å—Ç –¥–ª—è –∞–Ω–∞–ª–∏–∑–∞</div>';
                return;
            }

            const vector = textToVector(inputText);
            const predictions = mlModel.predict(inputText);

            let html = `
                    <div class="result">
                        <h3>–ê–Ω–∞–ª–∏–∑ —Ç–µ–∫—Å—Ç–∞:</h3>
                        <p><strong>–û—Ä–∏–≥–∏–Ω–∞–ª—å–Ω—ã–π —Ç–µ–∫—Å—Ç:</strong> "${inputText}"</p>
                        <p><strong>–ù–æ—Ä–º–∞–ª–∏–∑–æ–≤–∞–Ω–Ω—ã–π —Ç–µ–∫—Å—Ç:</strong> "${normalizeText(inputText)}"</p>

                        <h4>–í–µ–∫—Ç–æ—Ä–Ω–æ–µ –ø—Ä–µ–¥—Å—Ç–∞–≤–ª–µ–Ω–∏–µ (–ø–µ—Ä–≤—ã–µ 50 —ç–ª–µ–º–µ–Ω—Ç–æ–≤):</h4>
                        <div class="vector-visual">
                `;

            // –í–∏–∑—É–∞–ª–∏–∑–∞—Ü–∏—è –≤–µ–∫—Ç–æ—Ä–∞
            for (let i = 0; i < Math.min(70, vector.length); i++) {
                const isActive = vector[i] > 0.01;
                html += `<div class="vector-cell ${isActive ? 'active' : ''}" title="${COMBINED_ALPHABET[i]}: ${vector[i].toFixed(3)}">${isActive ? '‚óè' : '‚óã'}</div>`;
            }

            html += `</div><p>–†–∞–∑–º–µ—Ä–Ω–æ—Å—Ç—å –≤–µ–∫—Ç–æ—Ä–∞: ${vector.length}</p>`;

            html += `<h4>–†–µ–∑—É–ª—å—Ç–∞—Ç—ã –∫–ª–∞—Å—Å–∏—Ñ–∏–∫–∞—Ü–∏–∏:</h4>`;

            predictions.forEach(pred => {
                const width = Math.max(5, pred.similarity * 100);
                html += `
                        <div>
                            <strong>${pred.category}</strong>
                            <div class="similarity-bar">
                                <div class="similarity-fill" style="width: ${width}%"></div>
                            </div>
                            <span>–°—Ö–æ–¥—Å—Ç–≤–æ: ${(pred.similarity * 100).toFixed(1)}% (${pred.confidence})</span>
                        </div>
                    `;
            });

            // –î–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω—ã–π –∞–Ω–∞–ª–∏–∑ –∫–ª—é—á–µ–≤—ã—Ö —Å–ª–æ–≤
            const words = normalizeText(inputText).split(' ');
            const uniqueWords = [...new Set(words)];

            html += `<h4>–ö–ª—é—á–µ–≤—ã–µ —Å–ª–æ–≤–∞:</h4><ul>`;
            uniqueWords.forEach(word => {
                if (word.length > 2) {
                    html += `<li>${word}</li>`;
                }
            });
            html += `</ul>`;

            html += `</div>`;
            resultsDiv.innerHTML = html;
        }

        // –§—É–Ω–∫—Ü–∏—è –¥–ª—è —Ç–µ—Å—Ç–æ–≤—ã—Ö –∑–∞–ø—Ä–æ—Å–æ–≤
        function testQuery(query) {
            document.getElementById('inputText').value = query;
            analyzeText();
        }

        // –ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏–π –∞–Ω–∞–ª–∏–∑ –ø—Ä–∏ –∑–∞–≥—Ä—É–∑–∫–µ
        window.onload = function () {
            analyzeText();
        };
    </script>
</body>
</html>
