<!DOCTYPE html>
<html>
<head>
    <title>WebGPU-—É—Å–∫–æ—Ä–µ–Ω–Ω–∞—è –Ω–µ–π—Ä–æ—Å–µ—Ç—å –¥–ª—è –≤–∞–∫–∞–Ω—Å–∏–π</title>
    <meta charset="utf-8">
    <style>
        body {
            font-family: sans-serif;
            padding: 20px;
        }

        textarea {
            width: 100%;
            height: 150px;
            margin: 10px 0;
        }

        button {
            padding: 10px 20px;
            font-size: 16px;
        }

        #result {
            margin-top: 20px;
            padding: 15px;
            background: #f0f8ff;
            border-radius: 5px;
        }

        .loading {
            color: #666;
            font-style: italic;
        }
    </style>
</head>
<body>
    <h1>üéØ WebGPU-—É—Å–∫–æ—Ä–µ–Ω–Ω–∞—è –Ω–µ–π—Ä–æ—Å–µ—Ç—å –¥–ª—è –∫–ª–∞—Å—Å–∏—Ñ–∏–∫–∞—Ü–∏–∏ –≤–∞–∫–∞–Ω—Å–∏–π</h1>
    <p><em>–û–±—É—á–∞–µ—Ç—Å—è –Ω–∞ –≤–∞—à–∏—Ö –¥–∞–Ω–Ω—ã—Ö ‚Äî –±–µ–∑ –±–∏–±–ª–∏–æ—Ç–µ–∫, —Ç–æ–ª—å–∫–æ —á–∏—Å—Ç—ã–π JS + WebGPU</em></p>

    <textarea id="vacancy" placeholder="–í—Å—Ç–∞–≤—å—Ç–µ —Ç–µ–∫—Å—Ç –≤–∞–∫–∞–Ω—Å–∏–∏..."></textarea><br>
    <button onclick="classify()">–û–ø—Ä–µ–¥–µ–ª–∏—Ç—å —É—Ä–æ–≤–µ–Ω—å</button>
    <button onclick="trainModel()">üîÑ –û–±—É—á–∏—Ç—å –º–æ–¥–µ–ª—å –Ω–∞ –Ω–æ–≤—ã—Ö –¥–∞–Ω–Ω—ã—Ö</button>
    <div id="result"></div>
    <div id="status" class="loading">–ü—Ä–æ–≤–µ—Ä–∫–∞ WebGPU...</div>

    <script>
    // =========================
    // 1. –ü–†–ò–ó–ù–ê–ö–ò –ò–ó –¢–ï–ö–°–¢–ê (–±–µ–∑ –∏–∑–º–µ–Ω–µ–Ω–∏–π)
    // =========================
    function extractFeatures(text) {
      if (!text) return Array(20).fill(0);

      const words = text.split(/\s+/);
      const lowerText = text.toLowerCase();

      const complexVerbs = "—Ä–∞–∑—Ä–∞–±–∞—Ç—ã–≤–∞–ª,–æ–ø—Ç–∏–º–∏–∑–∏—Ä–æ–≤–∞–ª,—Ä—É–∫–æ–≤–æ–¥–∏–ª,–ø—Ä–æ–µ–∫—Ç–∏—Ä–æ–≤–∞–ª,–≤–Ω–µ–¥—Ä—è–ª,–º–∞—Å—à—Ç–∞–±–∏—Ä–æ–≤–∞–ª,–Ω–∞—Å—Ç—Ä–∞–∏–≤–∞–ª,–≤—ë–ª,–æ—Ä–≥–∞–Ω–∏–∑–æ–≤–∞–ª,–ø—Ä–µ–¥–ª–æ–∂–∏–ª,—Ä–µ–∞–ª–∏–∑–æ–≤–∞–ª,—Ä–µ—à–∏–ª,–æ–ø—Ä–µ–¥–µ–ª–∏–ª,–≤—ã–±—Ä–∞–ª,—Å–ø—Ä–æ–µ–∫—Ç–∏—Ä–æ–≤–∞–ª".split(',');
      const techLevel1 = "python,js,java,react,node,sql,git,github,docker,api,rest,http,linux,ubuntu,macos,window".split(',');
      const techLevel2 = "kubernetes,ci/cd,jenkins,github actions,postgres,redis,mongodb,nginx,apache,load balancing,monitoring,logging,debugging".split(',');
      const techLevel3 = "architect,architecture,scalability,high availability,refactoring,design pattern,team lead,mentor,performance optimization,security,infrastructure,deployment pipeline,observability,monitoring system,incident response".split(',');

      const features = [
        text.length, // 0
        words.length, // 1
        complexVerbs.filter(v => text.includes(v)).length, // 2
        techLevel1.filter(t => lowerText.includes(t)).length, // 3
        techLevel2.filter(t => lowerText.includes(t)).length, // 4
        techLevel3.filter(t => lowerText.includes(t)).length, // 5
        (lowerText.match(/\b(—è|–º–æ–π|–º–Ω–µ)\b/g) || []).length, // 6
        (lowerText.match(/\b(–∫–æ–º–∞–Ω–¥–∞|–∫–æ–ª–ª–µ–≥–∏|—Ä—É–∫–æ–≤–æ–¥–∏–ª|–≤–µ–ª|–æ–±—É—á–∞–ª|–Ω–∞—Å—Ç–∞–≤–ª—è–ª)\b/g) || []).length, // 7
        (text.match(/!/g) || []).length, // 8
        (text.match(/;/g) || []).length, // 9
        (text.match(/[-‚Äì‚Äî]/g) || []).length, // 10
        (text.match(/\n/g) || []).length, // 11
        (text.match(/\d/g) || []).length, // 12
        (text.match(/[A-Z]/g) || []).length / text.length, // 13
        lowerText.includes("–±–µ–∑ –æ–ø—ã—Ç–∞") ? 1 : 0, // 14
        lowerText.includes("–æ–ø—ã—Ç –æ—Ç") ? 1 : 0, // 15
        lowerText.includes("—Ç—Ä–µ–±–æ–≤–∞–Ω–∏—è") ? 1 : 0, // 16
        lowerText.includes("–º—ã –ø—Ä–µ–¥–ª–∞–≥–∞–µ–º") ? 1 : 0, // 17
        lowerText.includes("–±—É–¥–µ—Ç–µ –∑–∞–Ω–∏–º–∞—Ç—å—Å—è") ? 1 : 0, // 18
        lowerText.includes("–æ–±—è–∑–∞–Ω–Ω–æ—Å—Ç–∏") ? 1 : 0, // 19
      ];

      return features;
    }

    // =========================
    // 2. WEBGPU –ù–ï–ô–†–û–°–ï–¢–¨ (–≤—Å—è –ª–æ–≥–∏–∫–∞ –∑–¥–µ—Å—å)
    // =========================
    class WebGPUNeuralNetwork {
      constructor(inputSize = 20, hiddenSize = 12, outputSize = 3, learningRate = 0.1) {
        this.inputSize = inputSize;
        this.hiddenSize = hiddenSize;
        this.outputSize = outputSize;
        this.learningRate = learningRate;
        this.device = null;
        this.pipeline = null;
        this.buffers = {};
        this.loaded = false;
        this.isTraining = false;
      }

      async init() {
        if (!navigator.gpu) {
          throw new Error("WebGPU –Ω–µ –ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ—Ç—Å—è –≤ –≤–∞—à–µ–º –±—Ä–∞—É–∑–µ—Ä–µ. –ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ Chrome 113+ –∏–ª–∏ Edge 113+");
        }

        this.device = await navigator.gpu.requestAdapter().then(adapter => adapter.requestDevice());

        // –°–æ–∑–¥–∞—ë–º —à–µ–π–¥–µ—Ä
        const shaderCode = `
          @group(0) @binding(0) var<storage, read> input: array<f32>;
          @group(0) @binding(1) var<storage, read> weightsIH: array<f32>;
          @group(0) @binding(2) var<storage, read> weightsHO: array<f32>;
          @group(0) @binding(3) var<storage, read> biasH: array<f32>;
          @group(0) @binding(4) var<storage, read> biasO: array<f32>;
          @group(0) @binding(5) var<storage, read> targets: array<f32>;
          @group(0) @binding(6) var<storage, read_write> gradIH: array<f32>;
          @group(0) @binding(7) var<storage, read_write> gradHO: array<f32>;
          @group(0) @binding(8) var<storage, read_write> gradBiasH: array<f32>;
          @group(0) @binding(9) var<storage, read_write> gradBiasO: array<f32>;
          @group(0) @binding(10) var<storage, read_write> hidden: array<f32>;
          @group(0) @binding(11) var<storage, read_write> output: array<f32>;

          @compute @workgroup_size(1)
          fn forward(@builtin(global_invocation_id) id: vec3<u32>) {
            let i = id.x;
            if (i >= ${this.hiddenSize}) {
                return;
            }

            var sum = 0.0;
            for (var j = 0u; j < ${this.inputSize}; j = j + 1u) {
              sum = sum + input[j] * weightsIH[i * ${this.inputSize} + j];
            }
            hidden[i] = 1.0 / (1.0 + exp(-sum - biasH[i]));
          }

          @compute @workgroup_size(1)
          fn forwardOutput(@builtin(global_invocation_id) id: vec3<u32>) {
            let i = id.x;
            if (i >= ${this.outputSize}) {
                return;
            }

            var sum = 0.0;
            for (var j = 0u; j < ${this.hiddenSize}; j = j + 1u) {
              sum = sum + hidden[j] * weightsHO[i * ${this.hiddenSize} + j];
            }
            output[i] = 1.0 / (1.0 + exp(-sum - biasO[i]));
          }

          @compute @workgroup_size(1)
          fn backward(@builtin(global_invocation_id) id: vec3<u32>) {
            let i = id.x;
            if (i >= ${this.outputSize}) {
                return;    
            }

            let err = output[i] - targets[i];
            let deriv = output[i] * (1.0 - output[i]);
            let delta = err * deriv;

            // –û–±–Ω–æ–≤–ª—è–µ–º –≥—Ä–∞–¥–∏–µ–Ω—Ç—ã –≤—ã—Ö–æ–¥–Ω–æ–≥–æ —Å–ª–æ—è
            for (var j = 0u; j < ${this.hiddenSize}; j = j + 1u) {
              atomicAdd(&gradHO[i * ${this.hiddenSize} + j], delta * hidden[j]);
            }
            atomicAdd(&gradBiasO[i], delta);

            // –ì—Ä–∞–¥–∏–µ–Ω—Ç—ã —Å–∫—Ä—ã—Ç–æ–≥–æ —Å–ª–æ—è
            for (var j = 0u; j < ${this.hiddenSize}; j = j + 1u) {
              let herr = delta * weightsHO[i * ${this.hiddenSize} + j];
              let hderiv = hidden[j] * (1.0 - hidden[j]);
              let hdelta = herr * hderiv;

              for (var k = 0u; k < ${this.inputSize}; k = k + 1u) {
                atomicAdd(&gradIH[j * ${this.inputSize} + k], hdelta * input[k]);
              }
              atomicAdd(&gradBiasH[j], hdelta);
            }
          }

          @compute @workgroup_size(1)
          fn updateWeights(@builtin(global_invocation_id) id: vec3<u32>) {
            let i = id.x;
            if (i >= ${this.hiddenSize * this.inputSize}) {
              let idx = i;
              let g = gradIH[idx];
              weightsIH[idx] = weightsIH[idx] - ${this.learningRate} * g;
              gradIH[idx] = 0.0;
            }

            if (i >= ${this.hiddenSize * this.inputSize} && i < ${this.hiddenSize * this.inputSize + this.hiddenSize * this.outputSize}) {
              let idx = i - ${this.hiddenSize * this.inputSize};
              let g = gradHO[idx];
              weightsHO[idx] = weightsHO[idx] - ${this.learningRate} * g;
              gradHO[idx] = 0.0;
            }

            if (i >= ${this.hiddenSize * this.inputSize + this.hiddenSize * this.outputSize} && i < ${this.hiddenSize * this.inputSize + this.hiddenSize * this.outputSize + this.hiddenSize}) {
              let idx = i - ${this.hiddenSize * this.inputSize + this.hiddenSize * this.outputSize};
              let g = gradBiasH[idx];
              biasH[idx] = biasH[idx] - ${this.learningRate} * g;
              gradBiasH[idx] = 0.0;
            }

            if (i >= ${this.hiddenSize * this.inputSize + this.hiddenSize * this.outputSize + this.hiddenSize} && i < ${this.hiddenSize * this.inputSize + this.hiddenSize * this.outputSize + this.hiddenSize + this.outputSize}) {
              let idx = i - ${this.hiddenSize * this.inputSize + this.hiddenSize * this.outputSize + this.hiddenSize};
              let g = gradBiasO[idx];
              biasO[idx] = biasO[idx] - ${this.learningRate} * g;
              gradBiasO[idx] = 0.0;
            }
          }
        `;

        const shaderModule = this.device.createShaderModule({ code: shaderCode });

        // –°–æ–∑–¥–∞—ë–º –≤—ã—á–∏—Å–ª–∏—Ç–µ–ª—å–Ω—ã–µ –ø–∞–π–ø–ª–∞–π–Ω—ã
        this.pipelineForward = this.device.createComputePipeline({
          layout: "auto",
          compute: { module: shaderModule, entryPoint: "forward" }
        });

        this.pipelineForwardOutput = this.device.createComputePipeline({
          layout: "auto",
          compute: { module: shaderModule, entryPoint: "forwardOutput" }
        });

        this.pipelineBackward = this.device.createComputePipeline({
          layout: "auto",
          compute: { module: shaderModule, entryPoint: "backward" }
        });

        this.pipelineUpdateWeights = this.device.createComputePipeline({
          layout: "auto",
          compute: { module: shaderModule, entryPoint: "updateWeights" }
        });

        // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä—É–µ–º –±—É—Ñ–µ—Ä—ã
        this.initBuffers();

        this.loaded = true;
        document.getElementById("status").textContent = "‚úÖ WebGPU –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω–∞. –ú–æ–¥–µ–ª—å –≥–æ—Ç–æ–≤–∞.";
      }

      initBuffers() {
        const size = (inputSize, hiddenSize, outputSize) => ({
          input: inputSize,
          weightsIH: hiddenSize * inputSize,
          weightsHO: outputSize * hiddenSize,
          biasH: hiddenSize,
          biasO: outputSize,
          target: outputSize,
          gradIH: hiddenSize * inputSize,
          gradHO: outputSize * hiddenSize,
          gradBiasH: hiddenSize,
          gradBiasO: outputSize,
          hidden: hiddenSize,
          output: outputSize
        });

        const s = size(this.inputSize, this.hiddenSize, this.outputSize);

        // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä—É–µ–º –≤–µ—Å–∞ —Å–ª—É—á–∞–π–Ω–æ
        const weightsIH = new Float32Array(s.weightsIH).map(() => Math.random() - 0.5);
        const weightsHO = new Float32Array(s.weightsHO).map(() => Math.random() - 0.5);
        const biasH = new Float32Array(s.biasH).map(() => Math.random() - 0.5);
        const biasO = new Float32Array(s.biasO).map(() => Math.random() - 0.5);

        // –ì—Ä–∞–¥–∏–µ–Ω—Ç—ã ‚Äî –Ω—É–ª–∏
        const gradIH = new Float32Array(s.gradIH).fill(0);
        const gradHO = new Float32Array(s.gradHO).fill(0);
        const gradBiasH = new Float32Array(s.gradBiasH).fill(0);
        const gradBiasO = new Float32Array(s.gradBiasO).fill(0);

        // –ë—É—Ñ–µ—Ä—ã
        this.buffers.input = this.createBuffer(s.input * 4, GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST);
        this.buffers.weightsIH = this.createBuffer(s.weightsIH * 4, GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST | GPUBufferUsage.COPY_SRC);
        this.buffers.weightsHO = this.createBuffer(s.weightsHO * 4, GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST | GPUBufferUsage.COPY_SRC);
        this.buffers.biasH = this.createBuffer(s.biasH * 4, GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST | GPUBufferUsage.COPY_SRC);
        this.buffers.biasO = this.createBuffer(s.biasO * 4, GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST | GPUBufferUsage.COPY_SRC);
        this.buffers.target = this.createBuffer(s.target * 4, GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST);
        this.buffers.gradIH = this.createBuffer(s.gradIH * 4, GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST | GPUBufferUsage.COPY_SRC);
        this.buffers.gradHO = this.createBuffer(s.gradHO * 4, GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST | GPUBufferUsage.COPY_SRC);
        this.buffers.gradBiasH = this.createBuffer(s.gradBiasH * 4, GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST | GPUBufferUsage.COPY_SRC);
        this.buffers.gradBiasO = this.createBuffer(s.gradBiasO * 4, GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST | GPUBufferUsage.COPY_SRC);
        this.buffers.hidden = this.createBuffer(s.hidden * 4, GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST);
        this.buffers.output = this.createBuffer(s.output * 4, GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST);

        // –ó–∞–≥—Ä—É–∂–∞–µ–º –≤–µ—Å–∞
        this.device.queue.writeBuffer(this.buffers.weightsIH, 0, weightsIH);
        this.device.queue.writeBuffer(this.buffers.weightsHO, 0, weightsHO);
        this.device.queue.writeBuffer(this.buffers.biasH, 0, biasH);
        this.device.queue.writeBuffer(this.buffers.biasO, 0, biasO);
        this.device.queue.writeBuffer(this.buffers.gradIH, 0, gradIH);
        this.device.queue.writeBuffer(this.buffers.gradHO, 0, gradHO);
        this.device.queue.writeBuffer(this.buffers.gradBiasH, 0, gradBiasH);
        this.device.queue.writeBuffer(this.buffers.gradBiasO, 0, gradBiasO);
      }

      createBuffer(size, usage) {
        return this.device.createBuffer({ size, usage, mappedAtCreation: false });
      }

      async forward(inputArray) {
        this.device.queue.writeBuffer(this.buffers.input, 0, inputArray);

        const commandEncoder = this.device.createCommandEncoder();
        const passEncoder = commandEncoder.beginComputePass();

        // Forward: —Å–∫—Ä—ã—Ç—ã–π —Å–ª–æ–π
        passEncoder.setPipeline(this.pipelineForward);
        passEncoder.setBindGroup(0, this.createBindGroup([
          this.buffers.input,
          this.buffers.weightsIH,
          this.buffers.weightsHO,
          this.buffers.biasH,
          this.buffers.biasO,
          this.buffers.target,
          this.buffers.gradIH,
          this.buffers.gradHO,
          this.buffers.gradBiasH,
          this.buffers.gradBiasO,
          this.buffers.hidden,
          this.buffers.output
        ]));
        passEncoder.dispatchWorkgroups(this.hiddenSize);

        // Forward: –≤—ã—Ö–æ–¥–Ω–æ–π —Å–ª–æ–π
        passEncoder.setPipeline(this.pipelineForwardOutput);
        passEncoder.setBindGroup(0, this.createBindGroup([
          this.buffers.input,
          this.buffers.weightsIH,
          this.buffers.weightsHO,
          this.buffers.biasH,
          this.buffers.biasO,
          this.buffers.target,
          this.buffers.gradIH,
          this.buffers.gradHO,
          this.buffers.gradBiasH,
          this.buffers.gradBiasO,
          this.buffers.hidden,
          this.buffers.output
        ]));
        passEncoder.dispatchWorkgroups(this.outputSize);

        passEncoder.end();
        this.device.queue.submit([commandEncoder.finish()]);

        // –°—á–∏—Ç—ã–≤–∞–µ–º output
        const outputData = new Float32Array(this.outputSize);
        await this.buffers.output.mapAsync(GPUMapMode.READ);
        const outputBuffer = this.buffers.output.getMappedRange();
        outputData.set(new Float32Array(outputBuffer));
        this.buffers.output.unmap();

        return outputData;
      }

      async train(inputArray, targetArray) {
        // –ó–∞–ø–∏—Å—ã–≤–∞–µ–º –¥–∞–Ω–Ω—ã–µ
        this.device.queue.writeBuffer(this.buffers.input, 0, inputArray);
        this.device.queue.writeBuffer(this.buffers.target, 0, targetArray);

        // –û–±–Ω—É–ª—è–µ–º –≥—Ä–∞–¥–∏–µ–Ω—Ç—ã (–≤—Ä—É—á–Ω—É—é ‚Äî WebGPU –Ω–µ –∏–º–µ–µ—Ç atomicZero)
        const zero = new Float32Array(this.hiddenSize * this.inputSize).fill(0);
        this.device.queue.writeBuffer(this.buffers.gradIH, 0, zero);
        this.device.queue.writeBuffer(this.buffers.gradHO, 0, zero);
        this.device.queue.writeBuffer(this.buffers.gradBiasH, 0, zero);
        this.device.queue.writeBuffer(this.buffers.gradBiasO, 0, zero);

        // –ü—Ä—è–º–æ–π –ø—Ä–æ—Ö–æ–¥
        await this.forward(inputArray);

        // –û–±—Ä–∞—Ç–Ω—ã–π –ø—Ä–æ—Ö–æ–¥
        const commandEncoder = this.device.createCommandEncoder();
        const passEncoder = commandEncoder.beginComputePass();

        passEncoder.setPipeline(this.pipelineBackward);
        passEncoder.setBindGroup(0, this.createBindGroup([
          this.buffers.input,
          this.buffers.weightsIH,
          this.buffers.weightsHO,
          this.buffers.biasH,
          this.buffers.biasO,
          this.buffers.target,
          this.buffers.gradIH,
          this.buffers.gradHO,
          this.buffers.gradBiasH,
          this.buffers.gradBiasO,
          this.buffers.hidden,
          this.buffers.output
        ]));
        passEncoder.dispatchWorkgroups(this.outputSize + this.hiddenSize);

        passEncoder.end();
        this.device.queue.submit([commandEncoder.finish()]);

        // –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –≤–µ—Å–æ–≤
        const updateEncoder = this.device.createCommandEncoder();
        const updatePass = updateEncoder.beginComputePass();
        updatePass.setPipeline(this.pipelineUpdateWeights);
        updatePass.setBindGroup(0, this.createBindGroup([
          this.buffers.input,
          this.buffers.weightsIH,
          this.buffers.weightsHO,
          this.buffers.biasH,
          this.buffers.biasO,
          this.buffers.target,
          this.buffers.gradIH,
          this.buffers.gradHO,
          this.buffers.gradBiasH,
          this.buffers.gradBiasO,
          this.buffers.hidden,
          this.buffers.output
        ]));
        updatePass.dispatchWorkgroups(this.hiddenSize * this.inputSize + this.hiddenSize * this.outputSize + this.hiddenSize + this.outputSize);
        updatePass.end();
        this.device.queue.submit([updateEncoder.finish()]);
      }

      createBindGroup(bindings) {
        return this.device.createBindGroup({
          layout: this.pipelineForward.getBindGroupLayout(0),
          entries: bindings.map((buffer, idx) => ({ binding: idx, resource: { buffer } }))
        });
      }

      async predict(inputArray) {
        const output = await this.forward(inputArray);
        const maxIndex = output.reduce((max, val, idx) => (val > output[max] ? idx : max), 0);
        return {
          probabilities: output,
          level: ["–î–∂—É–Ω", "–ú–∏–¥–ª", "–°–µ–Ω—å–æ—Ä"][maxIndex],
          confidence: output[maxIndex]
        };
      }

      async saveModel() {
        const model = {
          inputSize: this.inputSize,
          hiddenSize: this.hiddenSize,
          outputSize: this.outputSize,
          learningRate: this.learningRate,
          weightsIH: await this.readBuffer(this.buffers.weightsIH),
          weightsHO: await this.readBuffer(this.buffers.weightsHO),
          biasH: await this.readBuffer(this.buffers.biasH),
          biasO: await this.readBuffer(this.buffers.biasO)
        };
        localStorage.setItem("webgpu_nn_model", JSON.stringify(model));
      }

      async loadModel() {
        const saved = localStorage.getItem("webgpu_nn_model");
        if (!saved) return false;

        const model = JSON.parse(saved);
        this.inputSize = model.inputSize;
        this.hiddenSize = model.hiddenSize;
        this.outputSize = model.outputSize;
        this.learningRate = model.learningRate;

        this.initBuffers();
        this.device.queue.writeBuffer(this.buffers.weightsIH, 0, model.weightsIH);
        this.device.queue.writeBuffer(this.buffers.weightsHO, 0, model.weightsHO);
        this.device.queue.writeBuffer(this.buffers.biasH, 0, model.biasH);
        this.device.queue.writeBuffer(this.buffers.biasO, 0, model.biasO);

        this.loaded = true;
        return true;
      }

      async readBuffer(buffer) {
        await buffer.mapAsync(GPUMapMode.READ);
        const data = new Float32Array(buffer.getMappedRange());
        buffer.unmap();
        return data;
      }
    }

    // =========================
    // 3. –î–ê–ù–ù–´–ï –ò –û–ë–£–ß–ï–ù–ò–ï
    // =========================
    const trainingData = [
      { text: "–ò—â–µ–º –¥–∂—É–Ω-—Ä–∞–∑—Ä–∞–±–æ—Ç—á–∏–∫–∞. –ò–º–µ–µ–º –æ–ø—ã—Ç —Ä–∞–±–æ—Ç—ã —Å Python. –ò–∑—É—á–∞–ª–∏ Git. –•–æ—á–µ–º —É—á–∏—Ç—å—Å—è.", level: 0 },
      { text: "–†–∞–∑—Ä–∞–±–∞—Ç—ã–≤–∞–µ–º API –Ω–∞ Node.js. –ò—Å–ø–æ–ª—å–∑—É–µ–º Docker, Redis, CI/CD. –ù—É–∂–µ–Ω –æ–ø—ã—Ç –æ—Ç 2 –ª–µ—Ç.", level: 1 },
      { text: "–†—É–∫–æ–≤–æ–¥–∏–º –∫–æ–º–∞–Ω–¥–æ–π –∏–∑ 5 —Ä–∞–∑—Ä–∞–±–æ—Ç—á–∏–∫–æ–≤. –ü—Ä–æ–µ–∫—Ç–∏—Ä—É–µ–º –∞—Ä—Ö–∏—Ç–µ–∫—Ç—É—Ä—É –Ω–∞ Kubernetes. –í–Ω–µ–¥—Ä—è–µ–º observability. –ú–∞—Å—à—Ç–∞–±–∏—Ä—É–µ–º —Å–∏—Å—Ç–µ–º—É. –ù–∞—Å—Ç–∞–≤–ª—è–µ–º –¥–∂—É–Ω–æ–≤.", level: 2 },
      { text: "–¢—Ä–µ–±—É–µ—Ç—Å—è frontend-—Ä–∞–∑—Ä–∞–±–æ—Ç—á–∏–∫. –ó–Ω–∞–Ω–∏–µ React, HTML, CSS. –û–ø—ã—Ç —Ä–∞–±–æ—Ç—ã –æ—Ç 1 –≥–æ–¥–∞.", level: 1 },
      { text: "–ë–µ–∑ –æ–ø—ã—Ç–∞. –ò–∑—É—á–∞–µ–º JavaScript. –ü–æ–º–æ–≥–∞–µ–º –∫–æ–º–∞–Ω–¥–µ. –û–±—É—á–µ–Ω–∏–µ –Ω–∞ –º–µ—Å—Ç–µ.", level: 0 },
      { text: "–ê—Ä—Ö–∏—Ç–µ–∫—Ç–æ—Ä –ü–û. –û–ø—Ä–µ–¥–µ–ª—è–µ–º —Å—Ç—Ä–∞—Ç–µ–≥–∏—é –º–∞—Å—à—Ç–∞–±–∏—Ä–æ–≤–∞–Ω–∏—è. –û—Ç–≤–µ—á–∞–µ–º –∑–∞ –æ—Ç–∫–∞–∑–æ—É—Å—Ç–æ–π—á–∏–≤–æ—Å—Ç—å. –í—ã–±–∏—Ä–∞–µ–º —Ç–µ—Ö–Ω–æ–ª–æ–≥–∏–∏. –í–µ–¥—ë–º —Ä–µ–≤—å—é –∫–æ–¥–∞. –†—É–∫–æ–≤–æ–¥–∏–º 3 –∫–æ–º–∞–Ω–¥–∞–º–∏.", level: 2 }
    ];

    const nn = new WebGPUNeuralNetwork();

    // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è WebGPU
    (async () => {
      try {
        await nn.init();
        const loaded = await nn.loadModel();
        if (loaded) {
          document.getElementById("status").textContent = "‚úÖ –ú–æ–¥–µ–ª—å –∑–∞–≥—Ä—É–∂–µ–Ω–∞ –∏–∑ localStorage.";
        } else {
          document.getElementById("status").textContent = "‚úÖ –ù–æ–≤–∞—è –º–æ–¥–µ–ª—å –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω–∞. –û–±—É—á–∏—Ç–µ –µ—ë!";
        }
      } catch (err) {
        document.getElementById("status").textContent = `‚ùå –û—à–∏–±–∫–∞: ${err.message}`;
      }
    })();

    // –û–±—É—á–µ–Ω–∏–µ –º–æ–¥–µ–ª–∏
    async function trainModel() {
      nn.isTraining = true;
      document.getElementById("status").textContent = "‚è≥ –û–±—É—á–µ–Ω–∏–µ –Ω–∞ GPU... (–º–æ–∂–µ—Ç –∑–∞–Ω—è—Ç—å 10-30 —Å–µ–∫)";

      const epochs = 1000;
      for (let epoch = 0; epoch < epochs; epoch++) {
        for (const item of trainingData) {
          const features = extractFeatures(item.text);
          const target = [0, 0, 0];
          target[item.level] = 1;

          await nn.train(new Float32Array(features), new Float32Array(target));
        }
        if (epoch % 200 === 0) {
          document.getElementById("status").textContent = `‚è≥ –û–±—É—á–µ–Ω–∏–µ... (${epoch}/${epochs})`;
        }
      }

      await nn.saveModel();
      document.getElementById("status").textContent = "‚úÖ –û–±—É—á–µ–Ω–∏–µ –∑–∞–≤–µ—Ä—à–µ–Ω–æ! –ú–æ–¥–µ–ª—å —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∞ –≤ localStorage.";
      nn.isTraining = false;
    }

    // –ö–ª–∞—Å—Å–∏—Ñ–∏–∫–∞—Ü–∏—è
    async function classify() {
      const text = document.getElementById("vacancy").value.trim();
      if (!text) {
        document.getElementById("result").innerHTML = "<p>–í–≤–µ–¥–∏—Ç–µ —Ç–µ–∫—Å—Ç –≤–∞–∫–∞–Ω—Å–∏–∏.</p>";
        return;
      }

      const features = extractFeatures(text);
      const result = await nn.predict(new Float32Array(features));

      document.getElementById("result").innerHTML = `
        <strong>üéØ –£—Ä–æ–≤–µ–Ω—å:</strong> ${result.level}<br>
        <strong>üí° –£–≤–µ—Ä–µ–Ω–Ω–æ—Å—Ç—å:</strong> ${result.confidence.toFixed(3)}<br>
        <strong>üìä –í–µ—Ä–æ—è—Ç–Ω–æ—Å—Ç–∏:</strong><br>
        –î–∂—É–Ω: ${result.probabilities[0].toFixed(3)}<br>
        –ú–∏–¥–ª: ${result.probabilities[1].toFixed(3)}<br>
        –°–µ–Ω—å–æ—Ä: ${result.probabilities[2].toFixed(3)}
      `;
    }
    </script>
</body>
</html>
