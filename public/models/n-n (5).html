<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <title>Обучение XOR на WebGPU</title>
</head>
<body>
    <h1>Обучение XOR на WebGPU</h1>
    <pre id="output"></pre>
    <script type="module">
        // ---------- Настройки сети и обучения ----------
        const EPOCHS = 10000;
        const LEARNING_RATE = 0.5;
        // Данные XOR: [x0, x1] -> y
        const XOR_DATA = [
            { input: [0, 0], output: 0 },
            { input: [0, 1], output: 1 },
            { input: [1, 0], output: 1 },
            { input: [1, 1], output: 0 }
        ];

        // Архитектура: 2 входа, 4 скрытых нейрона, 1 выход
        const INPUT_SIZE = 2;
        const HIDDEN_SIZE = 4;
        const OUTPUT_SIZE = 1;

        // Функция для логирования в HTML
        function log(message) {
            const pre = document.getElementById('output');
            pre.textContent += message + '\n';
        }

        // ---------- Инициализация WebGPU ----------
        async function initWebGPU() {
            if (!navigator.gpu) {
                throw new Error('WebGPU не поддерживается. Включите флаг или используйте Chrome/Edge с поддержкой WebGPU.');
            }
            const adapter = await navigator.gpu.requestAdapter();
            if (!adapter) {
                throw new Error('Не удалось получить адаптер WebGPU.');
            }
            const device = await adapter.requestDevice();
            return device;
        }

        // ---------- Создание буферов ----------
        function createBuffers(device) {
            // Веса и смещения инициализируем случайными числами (CPU)
            const weights1 = new Float32Array(INPUT_SIZE * HIDDEN_SIZE);
            const bias1 = new Float32Array(HIDDEN_SIZE);
            const weights2 = new Float32Array(HIDDEN_SIZE * OUTPUT_SIZE);
            const bias2 = new Float32Array(OUTPUT_SIZE);

            // Случайная инициализация (Xavier Glorot)
            function randomWeight() { return Math.random() * 2 - 1; }
            for (let i = 0; i < weights1.length; i++) weights1[i] = randomWeight();
            for (let i = 0; i < bias1.length; i++) bias1[i] = randomWeight();
            for (let i = 0; i < weights2.length; i++) weights2[i] = randomWeight();
            for (let i = 0; i < bias2.length; i++) bias2[i] = randomWeight();

            // Буферы GPU
            const weights1Buffer = device.createBuffer({
                size: weights1.byteLength,
                usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST,
                mappedAtCreation: true
            });
            new Float32Array(weights1Buffer.getMappedRange()).set(weights1);
            weights1Buffer.unmap();

            const bias1Buffer = device.createBuffer({
                size: bias1.byteLength,
                usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST,
                mappedAtCreation: true
            });
            new Float32Array(bias1Buffer.getMappedRange()).set(bias1);
            bias1Buffer.unmap();

            const weights2Buffer = device.createBuffer({
                size: weights2.byteLength,
                usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST,
                mappedAtCreation: true
            });
            new Float32Array(weights2Buffer.getMappedRange()).set(weights2);
            weights2Buffer.unmap();

            const bias2Buffer = device.createBuffer({
                size: bias2.byteLength,
                usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST,
                mappedAtCreation: true
            });
            new Float32Array(bias2Buffer.getMappedRange()).set(bias2);
            bias2Buffer.unmap();

            // Буферы для входных данных и целевого выхода (будем перезаписывать перед каждым шагом)
            const inputBuffer = device.createBuffer({
                size: INPUT_SIZE * Float32Array.BYTES_PER_ELEMENT,
                usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST
            });

            const targetBuffer = device.createBuffer({
                size: OUTPUT_SIZE * Float32Array.BYTES_PER_ELEMENT,
                usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST
            });

            // Буфер для learning rate (константа, можно uniform)
            const lrBuffer = device.createBuffer({
                size: Float32Array.BYTES_PER_ELEMENT,
                usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST
            });
            device.queue.writeBuffer(lrBuffer, 0, new Float32Array([LEARNING_RATE]));

            // Буфер для выходных данных при тестировании (4 примера)
            const testOutputBuffer = device.createBuffer({
                size: XOR_DATA.length * OUTPUT_SIZE * Float32Array.BYTES_PER_ELEMENT,
                usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC
            });

            return {
                weights1Buffer, bias1Buffer, weights2Buffer, bias2Buffer,
                inputBuffer, targetBuffer, lrBuffer, testOutputBuffer
            };
        }

        // ---------- Шейдер обучения (один пример за раз) ----------
        const trainingShaderCode = `
                struct Weights1 { data: array<f32, 8> };   // 2x4
                struct Bias1 { data: array<f32, 4> };
                struct Weights2 { data: array<f32, 4> };   // 4x1
                struct Bias2 { data: array<f32, 1> };
                struct Input { data: array<f32, 2> };
                struct mTarget { data: array<f32, 1> };
                struct Lr { value: f32 };

                @group(0) @binding(0) var<storage, read_write> weights1 : Weights1;
                @group(0) @binding(1) var<storage, read_write> bias1 : Bias1;
                @group(0) @binding(2) var<storage, read_write> weights2 : Weights2;
                @group(0) @binding(3) var<storage, read_write> bias2 : Bias2;
                @group(0) @binding(4) var<storage, read> input : Input;
                @group(0) @binding(5) var<storage, read> mtarget : mTarget;
                @group(0) @binding(6) var<uniform> lr : Lr;

                fn sigmoid(x: f32) -> f32 {
                    return 1.0 / (1.0 + exp(-x));
                }

                @compute @workgroup_size(1)
                fn main() {
                    let x = input.data[0];
                    let y = input.data[1];
                    let t = mtarget.data[0];

                    // Прямой проход
                    var hidden: array<f32, 4>;
                    for (var i = 0; i < 4; i = i + 1) {
                        var sum = bias1.data[i];
                        sum += weights1.data[0*4 + i] * x;   // вес от первого входа
                        sum += weights1.data[1*4 + i] * y;   // вес от второго входа
                        hidden[i] = sigmoid(sum);
                    }

                    var out_sum = bias2.data[0];
                    for (var i = 0; i < 4; i = i + 1) {
                        out_sum += weights2.data[i] * hidden[i];
                    }
                    let out = sigmoid(out_sum);

                    // Обратное распространение
                    let d_out = (out - t) * out * (1.0 - out);

                    // Градиенты для выходного слоя (сохраняем во временные переменные)
                    var grad_w2: array<f32, 4>;
                    for (var i = 0; i < 4; i = i + 1) {
                        grad_w2[i] = d_out * hidden[i];
                    }
                    let grad_b2 = d_out;

                    // Градиенты скрытого слоя (используем текущие weights2)
                    var d_hidden: array<f32, 4>;
                    for (var i = 0; i < 4; i = i + 1) {
                        d_hidden[i] = d_out * weights2.data[i] * hidden[i] * (1.0 - hidden[i]);
                    }

                    // Обновление весов и смещений (стохастический градиентный спуск)
                    for (var i = 0; i < 4; i = i + 1) {
                        weights2.data[i] = weights2.data[i] - lr.value * grad_w2[i];
                    }
                    bias2.data[0] = bias2.data[0] - lr.value * grad_b2;

                    for (var i = 0; i < 4; i = i + 1) {
                        bias1.data[i] = bias1.data[i] - lr.value * d_hidden[i];
                        weights1.data[0*4 + i] = weights1.data[0*4 + i] - lr.value * d_hidden[i] * x;
                        weights1.data[1*4 + i] = weights1.data[1*4 + i] - lr.value * d_hidden[i] * y;
                    }
                }
            `;

        // ---------- Шейдер тестирования (параллельно 4 примера) ----------
        const testShaderCode = `
                struct Weights1 { data: array<f32, 8> };
                struct Bias1 { data: array<f32, 4> };
                struct Weights2 { data: array<f32, 4> };
                struct Bias2 { data: array<f32, 1> };
                struct Inputs { data: array<f32, 8> };   // 4 примера по 2 числа
                struct Outputs { data: array<f32, 4> };  // 4 выхода

                @group(0) @binding(0) var<storage, read> weights1 : Weights1;
                @group(0) @binding(1) var<storage, read> bias1 : Bias1;
                @group(0) @binding(2) var<storage, read> weights2 : Weights2;
                @group(0) @binding(3) var<storage, read> bias2 : Bias2;
                @group(0) @binding(4) var<storage, read> inputs : Inputs;
                @group(0) @binding(5) var<storage, read_write> outputs : Outputs;

                fn sigmoid(x: f32) -> f32 {
                    return 1.0 / (1.0 + exp(-x));
                }

                @compute @workgroup_size(1)
                fn main(@builtin(global_invocation_id) id: vec3<u32>) {
                    let idx = id.x;
                    if (idx >= 4u) { return; }

                    let x = inputs.data[idx * 2u + 0u];
                    let y = inputs.data[idx * 2u + 1u];

                    // Прямой проход
                    var hidden: array<f32, 4>;
                    for (var i = 0u; i < 4u; i = i + 1u) {
                        var sum = bias1.data[i];
                        sum += weights1.data[0u*4u + i] * x;
                        sum += weights1.data[1u*4u + i] * y;
                        hidden[i] = sigmoid(sum);
                    }

                    var out_sum = bias2.data[0u];
                    for (var i = 0u; i < 4u; i = i + 1u) {
                        out_sum += weights2.data[i] * hidden[i];
                    }
                    outputs.data[idx] = sigmoid(out_sum);
                }
            `;

        // ---------- Основная функция ----------
        async function main() {
            try {
                log('Инициализация WebGPU...');
                const device = await initWebGPU();

                log('Создание буферов...');
                const buffers = createBuffers(device);

                // Создаем bind group layout для обучения
                const trainingBindGroupLayout = device.createBindGroupLayout({
                    entries: [
                        { binding: 0, visibility: GPUShaderStage.COMPUTE, buffer: { type: 'storage' } }, // weights1
                        { binding: 1, visibility: GPUShaderStage.COMPUTE, buffer: { type: 'storage' } }, // bias1
                        { binding: 2, visibility: GPUShaderStage.COMPUTE, buffer: { type: 'storage' } }, // weights2
                        { binding: 3, visibility: GPUShaderStage.COMPUTE, buffer: { type: 'storage' } }, // bias2
                        { binding: 4, visibility: GPUShaderStage.COMPUTE, buffer: { type: 'read-only-storage' } }, // input
                        { binding: 5, visibility: GPUShaderStage.COMPUTE, buffer: { type: 'read-only-storage' } }, // target
                        { binding: 6, visibility: GPUShaderStage.COMPUTE, buffer: { type: 'uniform' } } // lr
                    ]
                });

                // Создаем pipeline обучения
                const trainingPipeline = device.createComputePipeline({
                    layout: device.createPipelineLayout({ bindGroupLayouts: [trainingBindGroupLayout] }),
                    compute: {
                        module: device.createShaderModule({ code: trainingShaderCode }),
                        entryPoint: 'main'
                    }
                });

                // Bind group для обучения (будем использовать одну и ту же, но input/target будем менять через writeBuffer)
                const trainingBindGroup = device.createBindGroup({
                    layout: trainingBindGroupLayout,
                    entries: [
                        { binding: 0, resource: { buffer: buffers.weights1Buffer } },
                        { binding: 1, resource: { buffer: buffers.bias1Buffer } },
                        { binding: 2, resource: { buffer: buffers.weights2Buffer } },
                        { binding: 3, resource: { buffer: buffers.bias2Buffer } },
                        { binding: 4, resource: { buffer: buffers.inputBuffer } },
                        { binding: 5, resource: { buffer: buffers.targetBuffer } },
                        { binding: 6, resource: { buffer: buffers.lrBuffer } }
                    ]
                });

                log('Начинаем обучение...');
                const startTime = performance.now();

                // Цикл обучения
                for (let epoch = 0; epoch < EPOCHS; epoch++) {
                    for (let example of XOR_DATA) {
                        // Записываем вход и целевой выход в буферы
                        device.queue.writeBuffer(buffers.inputBuffer, 0, new Float32Array(example.input));
                        device.queue.writeBuffer(buffers.targetBuffer, 0, new Float32Array([example.output]));

                        // Запускаем compute shader
                        const commandEncoder = device.createCommandEncoder();
                        const passEncoder = commandEncoder.beginComputePass();
                        passEncoder.setPipeline(trainingPipeline);
                        passEncoder.setBindGroup(0, trainingBindGroup);
                        passEncoder.dispatchWorkgroups(1); // один пример
                        passEncoder.end();
                        device.queue.submit([commandEncoder.finish()]);
                    }

                    // Логируем каждые 1000 эпох
                    if ((epoch + 1) % 1000 === 0) {
                        log(`Эпоха ${epoch + 1} завершена`);
                    }
                }

                const endTime = performance.now();
                log(`Обучение завершено за ${(endTime - startTime).toFixed(2)} мс`);

                // ---------- Тестирование обученной сети ----------
                log('Тестирование сети:');

                // Создаем bind group layout для тестирования
                const testBindGroupLayout = device.createBindGroupLayout({
                    entries: [
                        { binding: 0, visibility: GPUShaderStage.COMPUTE, buffer: { type: 'read-only-storage' } }, // weights1
                        { binding: 1, visibility: GPUShaderStage.COMPUTE, buffer: { type: 'read-only-storage' } }, // bias1
                        { binding: 2, visibility: GPUShaderStage.COMPUTE, buffer: { type: 'read-only-storage' } }, // weights2
                        { binding: 3, visibility: GPUShaderStage.COMPUTE, buffer: { type: 'read-only-storage' } }, // bias2
                        { binding: 4, visibility: GPUShaderStage.COMPUTE, buffer: { type: 'read-only-storage' } }, // inputs (все 4)
                        { binding: 5, visibility: GPUShaderStage.COMPUTE, buffer: { type: 'storage' } } // outputs
                    ]
                });

                const testPipeline = device.createComputePipeline({
                    layout: device.createPipelineLayout({ bindGroupLayouts: [testBindGroupLayout] }),
                    compute: {
                        module: device.createShaderModule({ code: testShaderCode }),
                        entryPoint: 'main'
                    }
                });

                // Подготавливаем буфер со всеми входами
                const allInputs = new Float32Array(INPUT_SIZE * XOR_DATA.length);
                XOR_DATA.forEach((ex, i) => {
                    allInputs[i * 2] = ex.input[0];
                    allInputs[i * 2 + 1] = ex.input[1];
                });
                const allInputsBuffer = device.createBuffer({
                    size: allInputs.byteLength,
                    usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST,
                    mappedAtCreation: true
                });
                new Float32Array(allInputsBuffer.getMappedRange()).set(allInputs);
                allInputsBuffer.unmap();

                // Буфер для результатов (уже создан buffers.testOutputBuffer)
                // Заполним его нулями для чистоты
                device.queue.writeBuffer(buffers.testOutputBuffer, 0, new Float32Array(XOR_DATA.length));

                const testBindGroup = device.createBindGroup({
                    layout: testBindGroupLayout,
                    entries: [
                        { binding: 0, resource: { buffer: buffers.weights1Buffer } },
                        { binding: 1, resource: { buffer: buffers.bias1Buffer } },
                        { binding: 2, resource: { buffer: buffers.weights2Buffer } },
                        { binding: 3, resource: { buffer: buffers.bias2Buffer } },
                        { binding: 4, resource: { buffer: allInputsBuffer } },
                        { binding: 5, resource: { buffer: buffers.testOutputBuffer } }
                    ]
                });

                // Запускаем тестовый шейдер
                const commandEncoder = device.createCommandEncoder();
                const passEncoder = commandEncoder.beginComputePass();
                passEncoder.setPipeline(testPipeline);
                passEncoder.setBindGroup(0, testBindGroup);
                passEncoder.dispatchWorkgroups(XOR_DATA.length); // по одному на пример
                passEncoder.end();
                device.queue.submit([commandEncoder.finish()]);

                // Читаем результаты
                await buffers.testOutputBuffer.mapAsync(GPUMapMode.READ);
                const resultArray = new Float32Array(buffers.testOutputBuffer.getMappedRange());
                XOR_DATA.forEach((ex, i) => {
                    const predicted = resultArray[i];
                    log(`  ${ex.input[0]} XOR ${ex.input[1]} = ${ex.output} (предсказание: ${predicted.toFixed(4)})`);
                });
                buffers.testOutputBuffer.unmap();

                // Освобождаем ресурсы (по желанию)
                // device.destroy() - но обычно не требуется

            } catch (error) {
                log('Ошибка: ' + error.message);
                console.error(error);
            }
        }

        main();
    </script>
</body>
</html>