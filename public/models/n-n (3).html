<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <title>WebGPU Neural Network (–ò—Å–ø—Ä–∞–≤–ª–µ–Ω–Ω–∞—è)</title>
    <style>
        body {
            font-family: monospace;
            padding: 20px;
            background: #111;
            color: #eee;
        }

        pre {
            background: #222;
            padding: 15px;
            border-radius: 5px;
            overflow-x: auto;
        }

        button {
            margin: 10px;
            padding: 8px 16px;
            cursor: pointer;
        }
    </style>
</head>
<body>
    <h1>üß† WebGPU Neural Network (XOR, –±–µ–∑ NaN)</h1>
    <p>–ê—Ä—Ö–∏—Ç–µ–∫—Ç—É—Ä–∞: <strong>2 ‚Üí 8 ‚Üí 8 ‚Üí 1</strong> (—Å–∏–≥–º–æ–∏–¥–∞)</p>
    <button id="trainBtn">–û–±—É—á–∏—Ç—å XOR (100 —ç–ø–æ—Ö)</button>
    <button id="predictBtn">–ü—Ä–µ–¥—Å–∫–∞–∑–∞—Ç—å [0.5, 0.5]</button>
    <div id="status">–°—Ç–∞—Ç—É—Å: –æ–∂–∏–¥–∞–Ω–∏–µ</div>
    <pre id="log"></pre>

    <script>
        // ----------------------------------------------------------------------
        //  –ö–ª–∞—Å—Å –Ω–µ–π—Ä–æ—Å–µ—Ç–∏, –ø–æ–ª–Ω–æ—Å—Ç—å—é —Ä–∞–±–æ—Ç–∞—é—â–µ–π –Ω–∞ GPU —á–µ—Ä–µ–∑ WebGPU
        //  (–∏—Å–ø—Ä–∞–≤–ª–µ–Ω–Ω–∞—è –≤–µ—Ä—Å–∏—è: –µ–¥–∏–Ω—ã–π –±—É—Ñ–µ—Ä –∞–∫—Ç–∏–≤–∞—Ü–∏–π, –æ—Ç–¥–µ–ª—å–Ω—ã–π –±—É—Ñ–µ—Ä —Ü–µ–ª–µ–π)
        // ----------------------------------------------------------------------
        class WebGPUNeuralNetwork {
            constructor(architecture, learningRate = 0.1) {
                this.architecture = architecture;          // –º–∞—Å—Å–∏–≤ —Ä–∞–∑–º–µ—Ä–æ–≤ —Å–ª–æ—ë–≤, –Ω–∞–ø—Ä–∏–º–µ—Ä [2,8,8,1]
                this.learningRate = learningRate;
                this.layers = architecture.length;         // –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ —Å–ª–æ—ë–≤ (–≤–∫–ª—é—á–∞—è –≤—Ö–æ–¥–Ω–æ–π)

                // –ü–æ–ª—è –¥–ª—è WebGPU
                this.device = null;
                this.bindGroup = null;
                this.pipelineForward = null;
                this.pipelineBackward = null;
                this.pipelineUpdate = null;

                // –°–º–µ—â–µ–Ω–∏—è –≤ –º–∞—Å—Å–∏–≤–∞—Ö (–Ω–∞ CPU)
                this.layerOffsets = [0];        // —Å–º–µ—â–µ–Ω–∏–µ –Ω–∞—á–∞–ª–∞ –∫–∞–∂–¥–æ–≥–æ —Å–ª–æ—è –≤ –±—É—Ñ–µ—Ä–µ –∞–∫—Ç–∏–≤–∞—Ü–∏–π
                this.weightOffsets = [0];        // —Å–º–µ—â–µ–Ω–∏–µ –Ω–∞—á–∞–ª–∞ –≤–µ—Å–æ–≤ –∫–∞–∂–¥–æ–≥–æ —Å–ª–æ—è (–∫—Ä–æ–º–µ –≤—Ö–æ–¥–Ω–æ–≥–æ)

                // –ü–æ–¥—Å—á—ë—Ç –æ–±—â–µ–≥–æ –∫–æ–ª–∏—á–µ—Å—Ç–≤–∞ —ç–ª–µ–º–µ–Ω—Ç–æ–≤
                this.totalActivations = 0;
                this.totalWeights = 0;
                for (let i = 0; i < this.layers; i++) {
                    this.totalActivations += this.architecture[i];
                    if (i < this.layers - 1) {
                        // –≤–µ—Å–∞: (–≤—Ö–æ–¥ —Å–ª–æ—è) * (–≤—ã—Ö–æ–¥ —Å–ª–æ—è)
                        this.totalWeights += this.architecture[i] * this.architecture[i + 1];
                        this.layerOffsets.push(this.totalActivations);
                        this.weightOffsets.push(this.totalWeights);
                    }
                }
                this.totalBiases = this.totalActivations - this.architecture[0]; // bias –µ—Å—Ç—å —É –≤—Å–µ—Ö –Ω–µ–π—Ä–æ–Ω–æ–≤ –∫—Ä–æ–º–µ –≤—Ö–æ–¥–Ω–æ–≥–æ —Å–ª–æ—è

                // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è WebGPU
                this.init();
            }

            async init() {
                if (!navigator.gpu) {
                    throw new Error('WebGPU –Ω–µ –ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ—Ç—Å—è –≤ —ç—Ç–æ–º –±—Ä–∞—É–∑–µ—Ä–µ');
                }

                const adapter = await navigator.gpu.requestAdapter();
                this.device = await adapter.requestDevice({
                    requiredLimits: {
                        maxStorageBuffersPerShaderStage: 10,
                        maxComputeWorkgroupStorageSize: 32768,
                        maxComputeInvocationsPerWorkgroup: 1024,
                    },
                });

                // –°–æ–∑–¥–∞—ë–º –≤—Å–µ –Ω–µ–æ–±—Ö–æ–¥–∏–º—ã–µ –±—É—Ñ–µ—Ä—ã
                this.createBuffers();

                // –°–æ–∑–¥–∞—ë–º layout –¥–ª—è bind group (–Ω—É–∂–µ–Ω –¥–æ —Å–æ–∑–¥–∞–Ω–∏—è –ø–∞–π–ø–ª–∞–π–Ω–æ–≤)
                this.createBindGroupLayout();

                // –°–æ–∑–¥–∞—ë–º –≤—ã—á–∏—Å–ª–∏—Ç–µ–ª—å–Ω—ã–µ –ø–∞–π–ø–ª–∞–π–Ω—ã (forward, backward, update)
                this.createComputePipelines();

                // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä—É–µ–º –≤–µ—Å–∞ –∏ —Å–º–µ—â–µ–Ω–∏—è —Å–ª—É—á–∞–π–Ω—ã–º–∏ —á–∏—Å–ª–∞–º–∏
                this.initializeWeightsAndBiases();

                // –ó–∞–≥—Ä—É–∂–∞–µ–º –¥–∞–Ω–Ω—ã–µ –Ω–∞ GPU
                this.uploadWeights();
                this.uploadBiases();
                this.uploadLayerSizes();
                this.uploadLayerOffsets();
                this.uploadWeightOffsets();
                this.uploadLearningRate();

                // –§–∏–Ω–∞–ª—å–Ω–æ–µ —Å–æ–∑–¥–∞–Ω–∏–µ bind group (–ø–æ—Å–ª–µ —Ç–æ–≥–æ –∫–∞–∫ –≤—Å–µ –±—É—Ñ–µ—Ä—ã –∏ layout –≥–æ—Ç–æ–≤—ã)
                this.createBindGroup();

                console.log('‚úÖ WebGPU Neural Network —É—Å–ø–µ—à–Ω–æ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω–∞');
            }

            // --------------------------------------------------------------
            //  –°–æ–∑–¥–∞–Ω–∏–µ –±—É—Ñ–µ—Ä–æ–≤ (–≤—Å–µ –∏–º–µ—é—Ç —Ä–∞–∑–º–µ—Ä, –∫—Ä–∞—Ç–Ω—ã–π 4KB –¥–ª—è –±–µ–∑–æ–ø–∞—Å–Ω–æ—Å—Ç–∏)
            // --------------------------------------------------------------
            createBuffers() {
                const MIN_SIZE = 4096; // –º–∏–Ω–∏–º–∞–ª—å–Ω—ã–π —Ä–∞–∑–º–µ—Ä –±—É—Ñ–µ—Ä–∞ –≤ –±–∞–π—Ç–∞—Ö
                const floatSize = 4;
                const uintSize = 4;

                // –î–ª—è –∞–∫—Ç–∏–≤–∞—Ü–∏–π –∏—Å–ø–æ–ª—å–∑—É–µ–º –û–î–ò–ù –±—É—Ñ–µ—Ä (–≤—Ö–æ–¥–Ω—ã–µ, —Å–∫—Ä—ã—Ç—ã–µ, –≤—ã—Ö–æ–¥–Ω—ã–µ ‚Äì –≤—Å–µ —Ö—Ä–∞–Ω—è—Ç—Å—è –∑–¥–µ—Å—å)
                this.buffers = {};

                // –ë—É—Ñ–µ—Ä –∞–∫—Ç–∏–≤–∞—Ü–∏–π (–≤—Å–µ —Å–ª–æ–∏ –ø–æ–¥—Ä—è–¥)
                this.buffers.activations = this.device.createBuffer({
                    size: Math.max(this.totalActivations * floatSize, MIN_SIZE),
                    usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST | GPUBufferUsage.COPY_SRC,
                });

                // –ë—É—Ñ–µ—Ä –≤–µ—Å–æ–≤
                this.buffers.weights = this.device.createBuffer({
                    size: Math.max(this.totalWeights * floatSize, MIN_SIZE),
                    usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST | GPUBufferUsage.COPY_SRC,
                });

                // –ë—É—Ñ–µ—Ä —Å–º–µ—â–µ–Ω–∏–π (biases) ‚Äî —Ö—Ä–∞–Ω—è—Ç—Å—è –≤ —Ç–æ–º –∂–µ –ø–æ—Ä—è–¥–∫–µ, —á—Ç–æ –∏ –∞–∫—Ç–∏–≤–∞—Ü–∏–∏, –Ω–æ —Ç–æ–ª—å–∫–æ –¥–ª—è –Ω–µ–≤—Ö–æ–¥–Ω—ã—Ö —Å–ª–æ—ë–≤
                this.buffers.biases = this.device.createBuffer({
                    size: Math.max(this.totalBiases * floatSize, MIN_SIZE),
                    usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST,
                });

                // –ë—É—Ñ–µ—Ä –¥–µ–ª—å—Ç (–æ—à–∏–±–æ–∫) ‚Äî —Ç–∞–∫–æ–≥–æ –∂–µ —Ä–∞–∑–º–µ—Ä–∞, –∫–∞–∫ –∞–∫—Ç–∏–≤–∞—Ü–∏–∏
                this.buffers.deltas = this.device.createBuffer({
                    size: Math.max(this.totalActivations * floatSize, MIN_SIZE),
                    usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST,
                });

                // –ë—É—Ñ–µ—Ä –¥–ª—è —Ü–µ–ª–µ–≤—ã—Ö –∑–Ω–∞—á–µ–Ω–∏–π (—Ä–∞–∑–º–µ—Ä = –≤—ã—Ö–æ–¥–Ω–æ–π —Å–ª–æ–π)
                this.buffers.targets = this.device.createBuffer({
                    size: Math.max(this.architecture[this.layers - 1] * floatSize, MIN_SIZE),
                    usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST,
                });

                // –ë—É—Ñ–µ—Ä —Ä–∞–∑–º–µ—Ä–æ–≤ —Å–ª–æ—ë–≤
                this.buffers.layerSizes = this.device.createBuffer({
                    size: Math.max(this.layers * uintSize, MIN_SIZE),
                    usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST,
                });

                // –ë—É—Ñ–µ—Ä —Å–º–µ—â–µ–Ω–∏–π —Å–ª–æ—ë–≤ –≤ –º–∞—Å—Å–∏–≤–µ –∞–∫—Ç–∏–≤–∞—Ü–∏–π
                this.buffers.layerOffsets = this.device.createBuffer({
                    size: Math.max(this.layers * uintSize, MIN_SIZE),
                    usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST,
                });

                // –ë—É—Ñ–µ—Ä —Å–º–µ—â–µ–Ω–∏–π –≤–µ—Å–æ–≤ –¥–ª—è –∫–∞–∂–¥–æ–≥–æ —Å–ª–æ—è (–∫—Ä–æ–º–µ –≤—Ö–æ–¥–Ω–æ–≥–æ)
                this.buffers.weightOffsets = this.device.createBuffer({
                    size: Math.max((this.layers - 1) * uintSize, MIN_SIZE),
                    usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST,
                });

                // –ë—É—Ñ–µ—Ä —Å–∫–æ—Ä–æ—Å—Ç–∏ –æ–±—É—á–µ–Ω–∏—è
                this.buffers.learningRate = this.device.createBuffer({
                    size: Math.max(floatSize, MIN_SIZE),
                    usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST,
                });
            }

            // --------------------------------------------------------------
            //  –ó–∞–ø–æ–ª–Ω–µ–Ω–∏–µ –±—É—Ñ–µ—Ä–æ–≤ –Ω–∞—á–∞–ª—å–Ω—ã–º–∏ –∑–Ω–∞—á–µ–Ω–∏—è–º–∏ (CPU -> GPU)
            // --------------------------------------------------------------
            initializeWeightsAndBiases() {
                // –í–µ—Å–∞: –¥–ª—è –∫–∞–∂–¥–æ–≥–æ —Å–ª–æ—è i (0..layers-2) –º–∞—Ç—Ä–∏—Ü–∞ [–≤—Ö–æ–¥] x [–≤—ã—Ö–æ–¥]
                this.weights = [];
                this.biases = [];

                for (let i = 0; i < this.layers - 1; i++) {
                    const inputSize = this.architecture[i];
                    const outputSize = this.architecture[i + 1];
                    const layerWeights = [];
                    const layerBiases = [];

                    for (let to = 0; to < outputSize; to++) {
                        const row = [];
                        for (let from = 0; from < inputSize; from++) {
                            // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è Xavier (—Ä–∞–≤–Ω–æ–º–µ—Ä–Ω–æ–µ –º–∞–ª–æ–µ)
                            row.push((Math.random() - 0.5) * 0.2);
                        }
                        layerWeights.push(row);
                        layerBiases.push(0.0); // biases –æ–±–Ω—É–ª—è–µ–º
                    }
                    this.weights.push(layerWeights);
                    this.biases.push(layerBiases);
                }
            }

            uploadWeights() {
                const data = new Float32Array(this.totalWeights);
                let idx = 0;
                for (let layer = 0; layer < this.weights.length; layer++) {
                    for (let to = 0; to < this.weights[layer].length; to++) {
                        for (let from = 0; from < this.weights[layer][to].length; from++) {
                            data[idx++] = this.weights[layer][to][from];
                        }
                    }
                }
                this.device.queue.writeBuffer(this.buffers.weights, 0, data);
            }

            uploadBiases() {
                const data = new Float32Array(this.totalBiases);
                let idx = 0;
                for (let layer = 0; layer < this.biases.length; layer++) {
                    for (let to = 0; to < this.biases[layer].length; to++) {
                        data[idx++] = this.biases[layer][to];
                    }
                }
                this.device.queue.writeBuffer(this.buffers.biases, 0, data);
            }

            uploadLayerSizes() {
                const data = new Uint32Array(this.architecture);
                this.device.queue.writeBuffer(this.buffers.layerSizes, 0, data);
            }

            uploadLayerOffsets() {
                const data = new Uint32Array(this.layerOffsets);
                this.device.queue.writeBuffer(this.buffers.layerOffsets, 0, data);
            }

            uploadWeightOffsets() {
                const data = new Uint32Array(this.weightOffsets);
                this.device.queue.writeBuffer(this.buffers.weightOffsets, 0, data);
            }

            uploadLearningRate() {
                const data = new Float32Array([this.learningRate]);
                this.device.queue.writeBuffer(this.buffers.learningRate, 0, data);
            }

            // --------------------------------------------------------------
            //  –°–æ–∑–¥–∞–Ω–∏–µ layout –¥–ª—è bind group (–≤—Å–µ –±—É—Ñ–µ—Ä—ã –ø—Ä–∏–≤—è–∑–∞–Ω—ã)
            // --------------------------------------------------------------
            createBindGroupLayout() {
                this.bindGroupLayout = this.device.createBindGroupLayout({
                    entries: [
                        { binding: 0, visibility: GPUShaderStage.COMPUTE, buffer: { type: 'storage' } }, // activations (read for forward/backward)
                        { binding: 1, visibility: GPUShaderStage.COMPUTE, buffer: { type: 'storage' } },          // weights (read-write)
                        { binding: 2, visibility: GPUShaderStage.COMPUTE, buffer: { type: 'storage' } },          // biases (read-write)
                        { binding: 3, visibility: GPUShaderStage.COMPUTE, buffer: { type: 'storage' } },          // deltas (read-write)
                        { binding: 4, visibility: GPUShaderStage.COMPUTE, buffer: { type: 'read-only-storage' } }, // targets (read-only)
                        { binding: 5, visibility: GPUShaderStage.COMPUTE, buffer: { type: 'read-only-storage' } }, // layerSizes
                        { binding: 6, visibility: GPUShaderStage.COMPUTE, buffer: { type: 'read-only-storage' } }, // layerOffsets
                        { binding: 7, visibility: GPUShaderStage.COMPUTE, buffer: { type: 'read-only-storage' } }, // weightOffsets
                        { binding: 8, visibility: GPUShaderStage.COMPUTE, buffer: { type: 'read-only-storage' } }, // learningRate
                    ]
                });
            }

            createBindGroup() {
                this.bindGroup = this.device.createBindGroup({
                    layout: this.bindGroupLayout,
                    entries: [
                        { binding: 0, resource: { buffer: this.buffers.activations } },
                        { binding: 1, resource: { buffer: this.buffers.weights } },
                        { binding: 2, resource: { buffer: this.buffers.biases } },
                        { binding: 3, resource: { buffer: this.buffers.deltas } },
                        { binding: 4, resource: { buffer: this.buffers.targets } },
                        { binding: 5, resource: { buffer: this.buffers.layerSizes } },
                        { binding: 6, resource: { buffer: this.buffers.layerOffsets } },
                        { binding: 7, resource: { buffer: this.buffers.weightOffsets } },
                        { binding: 8, resource: { buffer: this.buffers.learningRate } },
                    ]
                });
            }

            // --------------------------------------------------------------
            //  –®–µ–π–¥–µ—Ä—ã –∏ –ø–∞–π–ø–ª–∞–π–Ω—ã
            // --------------------------------------------------------------
            createComputePipelines() {
                // –®–µ–π–¥–µ—Ä –Ω–∞–ø–∏—Å–∞–Ω –Ω–∞ WGSL
                const shaderCode = `
                        // –ö–æ–Ω—Å—Ç–∞–Ω—Ç—ã (–¥–æ–ª–∂–Ω—ã —Å–æ–≤–ø–∞–¥–∞—Ç—å —Å —Ä–∞–∑–º–µ—Ä–∞–º–∏ –Ω–∞ CPU, –Ω–æ –º–æ–∂–Ω–æ –∏ –¥–∏–Ω–∞–º–∏—á–µ—Å–∫–∏)
                        const MAX_ACTIVATIONS = 1000u;
                        const MAX_WEIGHTS = 1024u;
                        const MAX_LAYERS = 10u;

                        // –°–∏–≥–º–æ–∏–¥–∞
                        fn sigmoid(x: f32) -> f32 {
                            return 1.0 / (1.0 + exp(-x));
                        }

                        // –ë—É—Ñ–µ—Ä—ã (—Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤—É—é—Ç bind group)
                        @group(0) @binding(0) var<storage, read_write> activations : array<f32>;
                        @group(0) @binding(1) var<storage, read_write> weights    : array<f32>;
                        @group(0) @binding(2) var<storage, read_write> biases     : array<f32>;
                        @group(0) @binding(3) var<storage, read_write> deltas     : array<f32>;
                        @group(0) @binding(4) var<storage, read>       targets    : array<f32>;
                        @group(0) @binding(5) var<storage, read>       layerSizes : array<u32>;
                        @group(0) @binding(6) var<storage, read>       layerOffsets : array<u32>;
                        @group(0) @binding(7) var<storage, read>       weightOffsets : array<u32>;
                        @group(0) @binding(8) var<storage, read>       learningRate : f32;

                        // -----------------------------------------------------------------
                        //  FORWARD: –≤—ã—á–∏—Å–ª—è–µ—Ç –≤—ã—Ö–æ–¥ —Å–ª–æ—è layer_idx (–æ—Ç 0 –¥–æ layers-2)
                        //  id.x = layer_idx, id.y = –∏–Ω–¥–µ–∫—Å –Ω–µ–π—Ä–æ–Ω–∞ –≤ —Å–ª–µ–¥—É—é—â–µ–º —Å–ª–æ–µ
                        // -----------------------------------------------------------------
                        @compute @workgroup_size(64)
                        fn forward(@builtin(global_invocation_id) id: vec3<u32>) {
                            let layer = id.x;
                            let neuron = id.y;
                            // –ü—Ä–æ–≤–µ—Ä–∫–∞ –≥—Ä–∞–Ω–∏—Ü: —Å–ª–æ–π –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å –Ω–µ –ø–æ—Å–ª–µ–¥–Ω–∏–º, –Ω–µ–π—Ä–æ–Ω –¥–æ–ª–∂–µ–Ω —Å—É—â–µ—Å—Ç–≤–æ–≤–∞—Ç—å –≤ —Å–ª–µ–¥—É—é—â–µ–º —Å–ª–æ–µ
                            if (layer >= arrayLength(&layerSizes) - 1u || neuron >= layerSizes[layer + 1u]) {
                                return;
                            }

                            let inputSize  = layerSizes[layer];
                            let outputSize = layerSizes[layer + 1u];
                            let weightOffs = weightOffsets[layer];
                            let inputOffs  = layerOffsets[layer];
                            let outputOffs = layerOffsets[layer + 1u];

                            var sum = 0.0f;
                            // –°–∫–∞–ª—è—Ä–Ω–æ–µ –ø—Ä–æ–∏–∑–≤–µ–¥–µ–Ω–∏–µ –≤—Ö–æ–¥–Ω—ã—Ö –∞–∫—Ç–∏–≤–∞—Ü–∏–π –Ω–∞ –≤–µ—Å–∞
                            for (var i = 0u; i < inputSize; i = i + 1u) {
                                // –í–µ—Å–∞ —Ö—Ä–∞–Ω—è—Ç—Å—è –∫–∞–∫ [from][to] (–∏–Ω–¥–µ–∫—Å = offset + i*outputSize + neuron)
                                let w = weights[weightOffs + i * outputSize + neuron];
                                let a = activations[inputOffs + i];
                                sum = sum + w * a;
                            }
                            // –î–æ–±–∞–≤–ª—è–µ–º —Å–º–µ—â–µ–Ω–∏–µ (bias) ‚Äî —Ö—Ä–∞–Ω—è—Ç—Å—è –ø–æ—Å–ª–µ–¥–æ–≤–∞—Ç–µ–ª—å–Ω–æ –¥–ª—è –∫–∞–∂–¥–æ–≥–æ —Å–ª–æ—è
                            let biasIdx = outputOffs + neuron; // —Å–º–µ—â–µ–Ω–∏—è –ª–µ–∂–∞—Ç –≤ activations? –Ω–µ—Ç, biases –æ—Ç–¥–µ–ª—å–Ω–æ
                            sum = sum + biases[biasIdx];       // –Ω–æ biases –∏–º–µ—é—Ç —Ç–æ—Ç –∂–µ –∏–Ω–¥–µ–∫—Å, —á—Ç–æ –∏ –∞–∫—Ç–∏–≤–∞—Ü–∏–∏

                            // –ó–∞–ø–∏—Å—ã–≤–∞–µ–º —Ä–µ–∑—É–ª—å—Ç–∞—Ç –ø–æ—Å–ª–µ —Å–∏–≥–º–æ–∏–¥—ã
                            activations[outputOffs + neuron] = sigmoid(sum);
                        }

                        // -----------------------------------------------------------------
                        //  BACKWARD: –≤—ã—á–∏—Å–ª—è–µ—Ç –¥–µ–ª—å—Ç—ã –¥–ª—è —Å–ª–æ—è layer
                        //  id.x = layer, id.y = –∏–Ω–¥–µ–∫—Å –Ω–µ–π—Ä–æ–Ω–∞ –≤ —Ç–µ–∫—É—â–µ–º —Å–ª–æ–µ (–¥–ª—è –∫–æ—Ç–æ—Ä–æ–≥–æ —Å—á–∏—Ç–∞–µ–º –¥–µ–ª—å—Ç—É)
                        //  –í–ù–ò–ú–ê–ù–ò–ï: –∑–∞–ø—É—Å–∫–∞–µ–º –≤ –æ–±—Ä–∞—Ç–Ω–æ–º –ø–æ—Ä—è–¥–∫–µ —Å–ª–æ—ë–≤ (–æ—Ç –ø—Ä–µ–¥–ø–æ—Å–ª–µ–¥–Ω–µ–≥–æ –∫ –ø–µ—Ä–≤–æ–º—É)
                        // -----------------------------------------------------------------
                        @compute @workgroup_size(64)
                        fn backward(@builtin(global_invocation_id) id: vec3<u32>) {
                            let layer = id.x;          // —Ç–µ–∫—É—â–∏–π —Å–ª–æ–π (–∏–Ω–¥–µ–∫—Å –æ—Ç 0 –¥–æ layers-2)
                            let neuron = id.y;
                            if (layer >= arrayLength(&layerSizes) - 1u || neuron >= layerSizes[layer + 1u]) {
                                return;
                            }

                            let outputOffs = layerOffsets[layer + 1u];   // —Å–º–µ—â–µ–Ω–∏–µ –∞–∫—Ç–∏–≤–∞—Ü–∏–π —Ç–µ–∫—É—â–µ–≥–æ —Å–ª–æ—è (–≤—ã—Ö–æ–¥ forward)
                            let deltaOffs  = outputOffs;                 // –¥–µ–ª—å—Ç—ã —Ö—Ä–∞–Ω—è—Ç—Å—è —Ç–∞–º –∂–µ, –≥–¥–µ –∏ –∞–∫—Ç–∏–≤–∞—Ü–∏–∏

                            // –ó–Ω–∞—á–µ–Ω–∏–µ –∞–∫—Ç–∏–≤–∞—Ü–∏–∏ –Ω–µ–π—Ä–æ–Ω–∞ (–ø–æ—Å–ª–µ —Å–∏–≥–º–æ–∏–¥—ã)
                            let a = activations[outputOffs + neuron];
                            let sigmoidDeriv = a * (1.0 - a);

                            // –ï—Å–ª–∏ —ç—Ç–æ –≤—ã—Ö–æ–¥–Ω–æ–π —Å–ª–æ–π (–ø–æ—Å–ª–µ–¥–Ω–∏–π)
                            if (layer == arrayLength(&layerSizes) - 2u) {
                                // –û—à–∏–±–∫–∞ = –ø—Ä–µ–¥—Å–∫–∞–∑–∞–Ω–∏–µ - —Ü–µ–ª—å
                                let err = a - targets[neuron];
                                deltas[deltaOffs + neuron] = err * sigmoidDeriv;
                            } else {
                                // –°–∫—Ä—ã—Ç—ã–π —Å–ª–æ–π: —Å—É–º–º–∞ –¥–µ–ª—å—Ç —Å–ª–µ–¥—É—é—â–µ–≥–æ —Å–ª–æ—è, –≤–∑–≤–µ—à–µ–Ω–Ω—ã—Ö –≤–µ—Å–∞–º–∏
                                let nextLayer = layer + 1u;
                                let nextSize = layerSizes[nextLayer + 1u];
                                let nextDeltaOffs = layerOffsets[nextLayer + 1u];
                                let nextWeightOffs = weightOffsets[nextLayer];

                                var sum = 0.0f;
                                for (var j = 0u; j < nextSize; j = j + 1u) {
                                    // –í–µ—Å–∞ –æ—Ç —Ç–µ–∫—É—â–µ–≥–æ –Ω–µ–π—Ä–æ–Ω–∞ (from) –∫ –Ω–µ–π—Ä–æ–Ω—É j —Å–ª–µ–¥—É—é—â–µ–≥–æ —Å–ª–æ—è (to)
                                    // –ò–Ω–¥–µ–∫—Å: offset + neuron * nextSize + j
                                    let w = weights[nextWeightOffs + neuron * nextSize + j];
                                    let d = deltas[nextDeltaOffs + j];
                                    sum = sum + w * d;
                                }
                                deltas[deltaOffs + neuron] = sum * sigmoidDeriv;
                            }
                        }

                        // -----------------------------------------------------------------
                        //  UPDATE: –æ–±–Ω–æ–≤–ª—è–µ—Ç –≤–µ—Å–∞ –∏ —Å–º–µ—â–µ–Ω–∏—è –¥–ª—è —Å–ª–æ—è layer
                        //  id.x = layer, id.y = –∏–Ω–¥–µ–∫—Å –Ω–µ–π—Ä–æ–Ω–∞ –≤ —Å–ª–æ–µ (–¥–ª—è –∫–æ—Ç–æ—Ä–æ–≥–æ –æ–±–Ω–æ–≤–ª—è–µ–º bias –∏ –≤–µ—Å–∞)
                        // -----------------------------------------------------------------
                        @compute @workgroup_size(64)
                        fn update(@builtin(global_invocation_id) id: vec3<u32>) {
                            let layer = id.x;
                            let neuron = id.y;
                            if (layer >= arrayLength(&layerSizes) - 1u || neuron >= layerSizes[layer + 1u]) {
                                return;
                            }

                            let inputSize  = layerSizes[layer];
                            let outputSize = layerSizes[layer + 1u];
                            let weightOffs = weightOffsets[layer];
                            let inputOffs  = layerOffsets[layer];
                            let deltaOffs  = layerOffsets[layer + 1u]; // –¥–µ–ª—å—Ç–∞ —Ç–µ–∫—É—â–µ–≥–æ –Ω–µ–π—Ä–æ–Ω–∞

                            let lr = learningRate;
                            let delta = deltas[deltaOffs + neuron];

                            // –û–±–Ω–æ–≤–ª—è–µ–º bias
                            let biasIdx = layerOffsets[layer + 1u] + neuron;
                            biases[biasIdx] = biases[biasIdx] - lr * delta;

                            // –û–±–Ω–æ–≤–ª—è–µ–º –≤–µ—Å–∞, –≤–µ–¥—É—â–∏–µ –∫ —ç—Ç–æ–º—É –Ω–µ–π—Ä–æ–Ω—É
                            for (var i = 0u; i < inputSize; i = i + 1u) {
                                let wIdx = weightOffs + i * outputSize + neuron;
                                let grad = delta * activations[inputOffs + i];
                                weights[wIdx] = weights[wIdx] - lr * grad;
                            }
                        }
                    `;

                const shaderModule = this.device.createShaderModule({ code: shaderCode });

                const pipelineLayout = this.device.createPipelineLayout({
                    bindGroupLayouts: [this.bindGroupLayout]
                });

                this.pipelineForward = this.device.createComputePipeline({
                    layout: pipelineLayout,
                    compute: { module: shaderModule, entryPoint: 'forward' }
                });

                this.pipelineBackward = this.device.createComputePipeline({
                    layout: pipelineLayout,
                    compute: { module: shaderModule, entryPoint: 'backward' }
                });

                this.pipelineUpdate = this.device.createComputePipeline({
                    layout: pipelineLayout,
                    compute: { module: shaderModule, entryPoint: 'update' }
                });
            }

            // --------------------------------------------------------------
            //  –û—Å–Ω–æ–≤–Ω—ã–µ –º–µ—Ç–æ–¥—ã –æ–±—É—á–µ–Ω–∏—è –∏ –ø—Ä–µ–¥—Å–∫–∞–∑–∞–Ω–∏—è
            // --------------------------------------------------------------

            // forward pass –¥–ª—è –æ–¥–Ω–æ–≥–æ –≤—Ö–æ–¥–∞, –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç –≤—ã—Ö–æ–¥–Ω–æ–π –º–∞—Å—Å–∏–≤ (Promise)
            async predict(input) {
                if (input.length !== this.architecture[0]) {
                    throw new Error(`–†–∞–∑–º–µ—Ä –≤—Ö–æ–¥–∞ ${input.length} != –æ–∂–∏–¥–∞–µ–º–æ–º—É ${this.architecture[0]}`);
                }

                // –ó–∞–ø–∏—Å—ã–≤–∞–µ–º –≤—Ö–æ–¥–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ –≤ –Ω–∞—á–∞–ª–æ –±—É—Ñ–µ—Ä–∞ –∞–∫—Ç–∏–≤–∞—Ü–∏–π
                const inputArray = new Float32Array(this.totalActivations);
                for (let i = 0; i < input.length; i++) {
                    inputArray[this.layerOffsets[0] + i] = input[i];
                }
                this.device.queue.writeBuffer(this.buffers.activations, 0, inputArray);

                // –ó–∞–ø—É—Å–∫–∞–µ–º forward –¥–ª—è –≤—Å–µ—Ö —Å–ª–æ—ë–≤
                const encoder = this.device.createCommandEncoder();
                const pass = encoder.beginComputePass();
                pass.setPipeline(this.pipelineForward);
                pass.setBindGroup(0, this.bindGroup);

                for (let layer = 0; layer < this.layers - 1; layer++) {
                    const workgroupY = Math.ceil(this.architecture[layer + 1] / 64);
                    pass.dispatchWorkgroups(1, workgroupY, 1);
                }
                pass.end();
                this.device.queue.submit([encoder.finish()]);

                // –ß—Ç–µ–Ω–∏–µ —Ä–µ–∑—É–ª—å—Ç–∞—Ç–∞ (–≤—ã—Ö–æ–¥–Ω–æ–π —Å–ª–æ–π) —á–µ—Ä–µ–∑ staging –±—É—Ñ–µ—Ä
                const outputSize = this.architecture[this.layers - 1];
                const outputByteSize = outputSize * 4;
                const staging = this.device.createBuffer({
                    size: outputByteSize,
                    usage: GPUBufferUsage.COPY_DST | GPUBufferUsage.MAP_READ
                });

                const copyEncoder = this.device.createCommandEncoder();
                copyEncoder.copyBufferToBuffer(
                    this.buffers.activations,
                    this.layerOffsets[this.layers - 1] * 4,
                    staging,
                    0,
                    outputByteSize
                );
                this.device.queue.submit([copyEncoder.finish()]);

                await staging.mapAsync(GPUMapMode.READ);
                const result = new Float32Array(staging.getMappedRange()).slice();
                staging.unmap();
                staging.destroy();
                return result;
            }

            // –û–±—É—á–µ–Ω–∏–µ –Ω–∞ –æ–¥–Ω–æ–º –ø—Ä–∏–º–µ—Ä–µ (input, target) –≤ —Ç–µ—á–µ–Ω–∏–µ –æ–¥–Ω–æ–≥–æ —à–∞–≥–∞ (—ç–ø–æ—Ö–∏)
            async trainStep(input, target) {
                // –ü–æ–¥–≥–æ—Ç–∞–≤–ª–∏–≤–∞–µ–º –±—É—Ñ–µ—Ä –∞–∫—Ç–∏–≤–∞—Ü–∏–π: –∑–∞–ø–∏—Å—ã–≤–∞–µ–º –≤—Ö–æ–¥
                const actData = new Float32Array(this.totalActivations);
                for (let i = 0; i < input.length; i++) {
                    actData[this.layerOffsets[0] + i] = input[i];
                }
                this.device.queue.writeBuffer(this.buffers.activations, 0, actData);

                // –ó–∞–ø–∏—Å—ã–≤–∞–µ–º —Ü–µ–ª–µ–≤—ã–µ –∑–Ω–∞—á–µ–Ω–∏—è –≤ –±—É—Ñ–µ—Ä targets
                const targetData = new Float32Array(target);
                this.device.queue.writeBuffer(this.buffers.targets, 0, targetData);

                // –°–æ–∑–¥–∞—ë–º –∫–æ–º–∞–Ω–¥—ã
                const encoder = this.device.createCommandEncoder();

                // ---- FORWARD ----
                const passF = encoder.beginComputePass();
                passF.setPipeline(this.pipelineForward);
                passF.setBindGroup(0, this.bindGroup);
                for (let layer = 0; layer < this.layers - 1; layer++) {
                    const workgroupY = Math.ceil(this.architecture[layer + 1] / 64);
                    passF.dispatchWorkgroups(1, workgroupY, 1);
                }
                passF.end();

                // ---- BACKWARD (–≤ –æ–±—Ä–∞—Ç–Ω–æ–º –ø–æ—Ä—è–¥–∫–µ) ----
                const passB = encoder.beginComputePass();
                passB.setPipeline(this.pipelineBackward);
                passB.setBindGroup(0, this.bindGroup);
                for (let layer = this.layers - 2; layer >= 0; layer--) {
                    const workgroupY = Math.ceil(this.architecture[layer + 1] / 64);
                    passB.dispatchWorkgroups(1, workgroupY, 1);
                }
                passB.end();

                // ---- UPDATE ----
                const passU = encoder.beginComputePass();
                passU.setPipeline(this.pipelineUpdate);
                passU.setBindGroup(0, this.bindGroup);
                for (let layer = 0; layer < this.layers - 1; layer++) {
                    const workgroupY = Math.ceil(this.architecture[layer + 1] / 64);
                    passU.dispatchWorkgroups(1, workgroupY, 1);
                }
                passU.end();

                this.device.queue.submit([encoder.finish()]);
                // –ñ–¥—ë–º –≤—ã–ø–æ–ª–Ω–µ–Ω–∏—è (–Ω–µ –æ–±—è–∑–∞—Ç–µ–ª—å–Ω–æ, –Ω–æ –¥–ª—è —Å–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∞—Ü–∏–∏ –º–æ–∂–Ω–æ –¥–æ–±–∞–≤–∏—Ç—å await)
                await this.device.queue.onSubmittedWorkDone();
            }

            // –û–±—É—á–µ–Ω–∏–µ –Ω–∞ –Ω–∞–±–æ—Ä–µ –¥–∞–Ω–Ω—ã—Ö (–º–∞—Å—Å–∏–≤ –ø—Ä–∏–º–µ—Ä–æ–≤) –≤ —Ç–µ—á–µ–Ω–∏–µ –Ω–µ—Å–∫–æ–ª—å–∫–∏—Ö —ç–ø–æ—Ö
            async train(dataSet, epochs = 100) {
                const log = document.getElementById('log');
                const status = document.getElementById('status');

                for (let epoch = 0; epoch < epochs; epoch++) {
                    // –ü–µ—Ä–µ–º–µ—à–∏–≤–∞–µ–º –ø—Ä–∏–º–µ—Ä—ã (–∑–¥–µ—Å—å –ø—Ä–æ—Å—Ç–æ –ø–æ –ø–æ—Ä—è–¥–∫—É)
                    for (let example of dataSet) {
                        await this.trainStep(example.input, example.target);
                    }

                    // –ö–∞–∂–¥—ã–µ 10 —ç–ø–æ—Ö –ª–æ–≥–∏—Ä—É–µ–º –æ—à–∏–±–∫—É –Ω–∞ –ø–µ—Ä–≤–æ–º –ø—Ä–∏–º–µ—Ä–µ –¥–ª—è –∫–æ–Ω—Ç—Ä–æ–ª—è
                    if (epoch % 10 === 0) {
                        const out = await this.predict(dataSet[0].input);
                        const loss = Math.abs(dataSet[0].target[0] - out[0]);
                        log.textContent += `–≠–ø–æ—Ö–∞ ${epoch}, loss: ${loss.toFixed(6)}\n`;
                        status.textContent = `–û–±—É—á–µ–Ω–∏–µ... —ç–ø–æ—Ö–∞ ${epoch}/${epochs}`;
                        if (isNaN(loss)) {
                            console.error(`NaN –Ω–∞ —ç–ø–æ—Ö–µ ${epoch}`);
                            break;
                        }
                    }
                }
                status.textContent = '–û–±—É—á–µ–Ω–∏–µ –∑–∞–≤–µ—Ä—à–µ–Ω–æ!';
                log.textContent += '‚úÖ –û–±—É—á–µ–Ω–∏–µ —É—Å–ø–µ—à–Ω–æ –∑–∞–≤–µ—Ä—à–µ–Ω–æ!\n';
            }
        }

        // --------------------------------------------------------------
        //  –ò—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ –Ω–µ–π—Ä–æ—Å–µ—Ç–∏ –¥–ª—è XOR
        // --------------------------------------------------------------
        (async () => {
            const logEl = document.getElementById('log');
            const statusEl = document.getElementById('status');

            if (!navigator.gpu) {
                logEl.textContent = '‚ùå WebGPU –Ω–µ –ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ—Ç—Å—è. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ Chrome 113+ —Å —Ñ–ª–∞–≥–æ–º "enable-unsafe-webgpu".';
                return;
            }

            // –°–æ–∑–¥–∞—ë–º —ç–∫–∑–µ–º–ø–ª—è—Ä –Ω–µ–π—Ä–æ—Å–µ—Ç–∏
            const nn = new WebGPUNeuralNetwork([2, 8, 8, 1], 0.1);

            // –ñ–¥—ë–º –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏–∏ (–∞—Å–∏–Ω—Ö—Ä–æ–Ω–Ω–æ)
            await new Promise(resolve => setTimeout(resolve, 500)); // –≥—Ä—É–±–æ, –Ω–æ –¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ

            // –î–∞–Ω–Ω—ã–µ –¥–ª—è XOR
            const xorData = [
                { input: [0, 0], target: [0] },
                { input: [0, 1], target: [1] },
                { input: [1, 0], target: [1] },
                { input: [1, 1], target: [0] }
            ];

            document.getElementById('trainBtn').addEventListener('click', async () => {
                logEl.textContent = '–û–±—É—á–µ–Ω–∏–µ XOR...\n';
                await nn.train(xorData, 100);

                // –ü—Ä–æ–≤–µ—Ä–∏–º –≤—Å–µ –ø—Ä–∏–º–µ—Ä—ã –ø–æ—Å–ª–µ –æ–±—É—á–µ–Ω–∏—è
                logEl.textContent += '\n--- –†–µ–∑—É–ª—å—Ç–∞—Ç—ã –ø–æ—Å–ª–µ –æ–±—É—á–µ–Ω–∏—è ---\n';
                for (let ex of xorData) {
                    const pred = await nn.predict(ex.input);
                    logEl.textContent += `–í—Ö–æ–¥: [${ex.input}] ‚Üí –í—ã—Ö–æ–¥: ${pred[0].toFixed(4)}  (—Ü–µ–ª—å: ${ex.target[0]})\n`;
                }
            });

            document.getElementById('predictBtn').addEventListener('click', async () => {
                const pred = await nn.predict([0.5, 0.5]);
                logEl.textContent += `–ü—Ä–µ–¥—Å–∫–∞–∑–∞–Ω–∏–µ [0.5, 0.5]: ${pred[0].toFixed(4)}\n`;
            });

            statusEl.textContent = '–ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –∑–∞–≤–µ—Ä—à–µ–Ω–∞. –ú–æ–∂–Ω–æ –æ–±—É—á–∞—Ç—å.';
        })();
    </script>
</body>
</html>